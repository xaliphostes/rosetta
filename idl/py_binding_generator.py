#!/usr/bin/env python3
"""
Rosetta Python Binding Generator
=================================

Generates Python bindings from Rosetta IDL files.
Uses the IDL parser to create pybind11 binding code.

Author: Rosetta Framework
License: MIT
"""

from typing import List, TextIO
from pathlib import Path
from rosetta_idl_parser import (
    InterfaceDefinition, Class, Method, Function, Field,
    Constructor, AccessMode, TypeConverter, Include
)


class PythonBindingGenerator:
    """Generate Python bindings from IDL"""

    def __init__(self, idl: InterfaceDefinition):
        self.idl = idl
        self.indent_level = 0

    def generate(self, output_path: Path):
        """Generate the binding file"""
        with open(output_path, 'w') as f:
            self._write_header(f)
            self._write_includes(f)
            self._write_registration_functions(f)
            self._write_module_definition(f)

    def _write_header(self, f: TextIO):
        """Write file header"""
        f.write(f"""// Auto-generated Python bindings for {self.idl.module.name}
// Generated by Rosetta IDL Parser
// DO NOT EDIT THIS FILE MANUALLY

""")

    def _write_includes(self, f: TextIO):
        """Write include directives"""
        # Standard includes
        f.write("#include <rosetta/extensions/generators/py_generator.h>\n")
        f.write("#include <rosetta/rosetta.h>\n")
        
        # User includes
        for include in self.idl.includes:
            f.write(f"{include.formatted}\n")
        
        f.write("\n")

    def _write_registration_functions(self, f: TextIO):
        """Write Rosetta registration functions"""
        f.write(f"// Rosetta class registrations\n")
        f.write(f"void register_{self.idl.module.name}_classes() {{\n")
        
        for cls in self.idl.classes:
            self._write_class_registration(f, cls)
        
        f.write("}\n\n")

    def _write_class_registration(self, f: TextIO, cls: Class):
        """Write registration for a single class"""
        f.write(f"    // Register {cls.name}\n")
        f.write(f"    ROSETTA_REGISTER_CLASS({cls.cpp_name})\n")
        
        # Constructors
        for ctor in cls.constructors:
            param_types = ", ".join([p.type for p in ctor.parameters])
            f.write(f"        .constructor<{param_types}>()\n")
        
        # Fields
        for field in cls.fields:
            if field.getter and field.setter:
                # Property with getter/setter
                f.write(f"        .property<{field.type}>(\"{field.name}\", "
                       f"&{cls.cpp_name}::{field.getter}, "
                       f"&{cls.cpp_name}::{field.setter})\n")
            elif field.getter:
                # Read-only property
                f.write(f"        .readonly_property<{field.type}>(\"{field.name}\", "
                       f"&{cls.cpp_name}::{field.getter})\n")
            else:
                # Direct field access
                cpp_field_name = field.cpp_name or field.name
                if field.access == AccessMode.READ_WRITE:
                    f.write(f"        .field(\"{field.name}\", &{cls.cpp_name}::{cpp_field_name})\n")
                elif field.access == AccessMode.READ_ONLY:
                    f.write(f"        .readonly_property<{field.type}>(\"{field.name}\", "
                           f"&{cls.cpp_name}::{cpp_field_name})\n")
        
        # Methods
        for method in cls.methods:
            cpp_method_name = method.cpp_name or method.name
            if method.pure_virtual:
                param_types = ", ".join([method.returns] + [p.type for p in method.parameters])
                f.write(f"        .pure_virtual_method<{param_types}>(\"{method.name}\")\n")
            elif method.override:
                f.write(f"        .override_method(\"{method.name}\", "
                       f"&{cls.cpp_name}::{cpp_method_name})\n")
            elif method.virtual:
                f.write(f"        .virtual_method(\"{method.name}\", "
                       f"&{cls.cpp_name}::{cpp_method_name})\n")
            else:
                f.write(f"        .method(\"{method.name}\", "
                       f"&{cls.cpp_name}::{cpp_method_name})\n")
        
        # Base classes
        for base in cls.base_classes:
            if base.inheritance_type.value == "virtual":
                f.write(f"        .virtually_inherits_from<{base.name}>()\n")
            else:
                f.write(f"        .inherits_from<{base.name}>()\n")
        
        # Auto-detect properties
        if cls.auto_detect_properties:
            f.write(f"        .auto_detect_properties()\n")
        
        f.write("        ;\n\n")

    def _write_module_definition(self, f: TextIO):
        """Write pybind11 module definition"""
        module_name = self.idl.module.name
        doc = self.idl.module.description or f"Python bindings for {module_name}"
        
        f.write(f"// Python module definition\n")
        f.write(f'BEGIN_PY_MODULE({module_name}, "{doc}") {{\n')
        f.write(f"    register_{module_name}_classes();\n\n")
        
        # Register type converters
        if self.idl.converters:
            f.write("    // Register type converters\n")
            for converter in self.idl.converters:
                self._write_converter_registration(f, converter)
            f.write("\n")
        
        # Bind classes
        f.write("    // Bind classes\n")
        for cls in self.idl.classes:
            f.write(f"    BIND_PY_CLASS({cls.cpp_name});\n")
        f.write("\n")
        
        # Bind free functions
        if self.idl.functions:
            f.write("    // Bind free functions\n")
            for func in self.idl.functions:
                self._write_function_binding(f, func)
            f.write("\n")
        
        # Utilities
        if self.idl.utilities and any([
            self.idl.utilities.version_info,
            self.idl.utilities.list_classes,
            self.idl.utilities.type_inspection
        ]):
            f.write("    // Add utilities\n")
            f.write("    BIND_PY_UTILITIES();\n\n")
        
        f.write("}\n")
        f.write("END_PY_MODULE()\n")

    def _write_converter_registration(self, f: TextIO, converter: TypeConverter):
        """Write type converter registration"""
        # Parse the type to determine what kind of converter to use
        type_str = converter.type
        
        if type_str.startswith("std::vector<"):
            # Extract element type
            elem_type = type_str[12:-1]  # Remove "std::vector<" and ">"
            f.write(f"    rosetta::py::bind_vector_type<{elem_type}>();\n")
        elif type_str.startswith("std::map<"):
            # Extract key and value types
            inner = type_str[9:-1]  # Remove "std::map<" and ">"
            key_type, val_type = self._split_template_args(inner)
            f.write(f"    rosetta::py::bind_map_type<{key_type}, {val_type}>();\n")
        elif type_str.startswith("std::set<"):
            elem_type = type_str[9:-1]
            f.write(f"    rosetta::py::bind_set_type<{elem_type}>();\n")
        elif type_str.startswith("std::array<"):
            # Extract type and size
            inner = type_str[11:-1]
            parts = self._split_template_args(inner)
            if len(parts) == 2:
                elem_type, size = parts
                f.write(f"    rosetta::py::bind_array_type<{elem_type}, {size}>();\n")
        elif type_str.startswith("std::unordered_map<"):
            inner = type_str[19:-1]
            key_type, val_type = self._split_template_args(inner)
            f.write(f"    rosetta::py::bind_unordered_map_type<{key_type}, {val_type}>();\n")
        elif type_str.startswith("std::unordered_set<"):
            elem_type = type_str[19:-1]
            f.write(f"    rosetta::py::bind_unordered_set_type<{elem_type}>();\n")
        elif type_str.startswith("std::deque<"):
            elem_type = type_str[11:-1]
            f.write(f"    rosetta::py::bind_deque_type<{elem_type}>();\n")

    def _split_template_args(self, args_str: str) -> List[str]:
        """Split template arguments handling nested templates"""
        result = []
        current = ""
        depth = 0
        
        for char in args_str:
            if char == '<':
                depth += 1
                current += char
            elif char == '>':
                depth -= 1
                current += char
            elif char == ',' and depth == 0:
                result.append(current.strip())
                current = ""
            else:
                current += char
        
        if current:
            result.append(current.strip())
        
        return result

    def _write_function_binding(self, f: TextIO, func: Function):
        """Write free function binding"""
        cpp_name = func.cpp_function_name
        doc = func.description or ""
        f.write(f'    BIND_FUNCTION({cpp_name}, "{doc}");\n')


# ============================================================================
# Main Entry Point
# ============================================================================

def generate_python_bindings(idl_file: Path, output_file: Path):
    """Generate Python bindings from an IDL file"""
    from rosetta_idl_parser import parse_idl
    
    idl = parse_idl(idl_file)
    if not idl:
        print(f"❌ Failed to parse IDL file: {idl_file}")
        return False
    
    generator = PythonBindingGenerator(idl)
    generator.generate(output_file)
    
    print(f"✅ Generated Python bindings: {output_file}")
    return True


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python py_binding_generator.py <idl_file.yaml> [output_file.cpp]")
        sys.exit(1)
    
    idl_file = Path(sys.argv[1])
    
    if len(sys.argv) >= 3:
        output_file = Path(sys.argv[2])
    else:
        output_file = Path(f"binding_{idl_file.stem}.cpp")
    
    success = generate_python_bindings(idl_file, output_file)
    sys.exit(0 if success else 1)