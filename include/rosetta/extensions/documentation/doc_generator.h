// ============================================================================
// Génération automatique de documentation
// ============================================================================
#pragma once
#include "../../core/registry.h"
#include <sstream>
#include <string>
#include <vector>

namespace rosetta::extensions {

    enum class DocFormat { Markdown, HTML, PlainText };

    class DocGenerator {
        DocFormat format_;

    public:
        explicit DocGenerator(DocFormat format = DocFormat::Markdown) : format_(format) {}

        std::string generate() const {
            std::stringstream ss;

            switch (format_) {
            case DocFormat::Markdown:
                generate_markdown(ss);
                break;
            case DocFormat::HTML:
                generate_html(ss);
                break;
            case DocFormat::PlainText:
                generate_plaintext(ss);
                break;
            }

            return ss.str();
        }

        std::string generate_class_doc(const std::string &class_name) const {
            std::stringstream ss;

            auto *holder = core::Registry::instance().get_by_name(class_name);
            if (!holder) {
                return "Class not found: " + class_name;
            }

            switch (format_) {
            case DocFormat::Markdown:
                generate_class_markdown(ss, class_name, *holder);
                break;
            case DocFormat::HTML:
                generate_class_html(ss, class_name, *holder);
                break;
            case DocFormat::PlainText:
                generate_class_plaintext(ss, class_name, *holder);
                break;
            }

            return ss.str();
        }

    private:
        void generate_markdown(std::stringstream &ss) const {
            auto &registry = core::Registry::instance();

            ss << "# API Documentation\n\n";
            ss << "Auto-generated by Rosetta\n\n";
            ss << "## Table of Contents\n\n";

            // Table des matières
            for (const auto &class_name : registry.list_classes()) {
                ss << "- [" << class_name << "](#" << to_anchor(class_name) << ")\n";
            }

            ss << "\n---\n\n";

            // Documentation de chaque classe
            for (const auto &class_name : registry.list_classes()) {
                auto *holder = registry.get_by_name(class_name);
                if (holder) {
                    generate_class_markdown(ss, class_name, *holder);
                }
            }
        }

        void generate_class_markdown(std::stringstream &ss, const std::string &class_name,
                                     const core::Registry::MetadataHolder &holder) const {
            const auto &inheritance = holder.get_inheritance();

            ss << "## " << class_name << "\n\n";

            // Badges
            if (inheritance.is_abstract) {
                ss << "![Abstract](https://img.shields.io/badge/abstract-class-blue) ";
            }
            if (inheritance.is_polymorphic) {
                ss << "![Polymorphic](https://img.shields.io/badge/polymorphic-yes-green) ";
            }
            ss << "\n\n";

            // Description
            ss << "### Description\n\n";
            ss << "*No description available*\n\n";

            // Héritage
            if (!inheritance.base_classes.empty()) {
                ss << "### Inheritance\n\n";
                ss << "Inherits from: ";
                bool first = true;
                for (const auto &base : inheritance.base_classes) {
                    if (!first)
                        ss << ", ";
                    ss << "`" << base.name << "`";
                    first = false;
                }
                ss << "\n\n";
            }

            // Membres virtuels
            if (!inheritance.vtable.methods.empty()) {
                ss << "### Virtual Methods\n\n";
                for (const auto &vmethod : inheritance.vtable.methods) {
                    ss << "- `" << vmethod.name << "`";
                    if (vmethod.is_pure_virtual)
                        ss << " (pure virtual)";
                    if (vmethod.is_override)
                        ss << " (override)";
                    ss << "\n";
                }
                ss << "\n";
            }

            ss << "---\n\n";
        }

        void generate_html(std::stringstream &ss) const {
            ss << "<!DOCTYPE html>\n";
            ss << "<html>\n<head>\n";
            ss << "<title>API Documentation</title>\n";
            ss << "<style>\n";
            ss << "body { font-family: Arial, sans-serif; margin: 40px; }\n";
            ss << "h1 { color: #333; }\n";
            ss << "h2 { color: #666; border-bottom: 1px solid #ddd; }\n";
            ss << ".badge { display: inline-block; padding: 3px 7px; ";
            ss << "background: #007bff; color: white; border-radius: 3px; }\n";
            ss << "</style>\n";
            ss << "</head>\n<body>\n";

            ss << "<h1>API Documentation</h1>\n";
            ss << "<p>Auto-generated by Rosetta</p>\n";

            auto &registry = core::Registry::instance();
            for (const auto &class_name : registry.list_classes()) {
                auto *holder = registry.get_by_name(class_name);
                if (holder) {
                    generate_class_html(ss, class_name, *holder);
                }
            }

            ss << "</body>\n</html>\n";
        }

        void generate_class_html(std::stringstream &ss, const std::string &class_name,
                                 const core::Registry::MetadataHolder &holder) const {
            const auto &inheritance = holder.get_inheritance();

            ss << "<h2>" << class_name << "</h2>\n";

            if (inheritance.is_abstract) {
                ss << "<span class=\"badge\">Abstract</span> ";
            }
            if (inheritance.is_polymorphic) {
                ss << "<span class=\"badge\">Polymorphic</span> ";
            }
            ss << "\n";

            ss << "<p><em>No description available</em></p>\n";
        }

        void generate_plaintext(std::stringstream &ss) const {
            ss << "API DOCUMENTATION\n";
            ss << "=================\n\n";
            ss << "Auto-generated by Rosetta\n\n";

            auto &registry = core::Registry::instance();
            for (const auto &class_name : registry.list_classes()) {
                auto *holder = registry.get_by_name(class_name);
                if (holder) {
                    generate_class_plaintext(ss, class_name, *holder);
                }
            }
        }

        void generate_class_plaintext(std::stringstream &ss, const std::string &class_name,
                                      const core::Registry::MetadataHolder &holder) const {
            const auto &inheritance = holder.get_inheritance();

            ss << class_name << "\n";
            ss << std::string(class_name.length(), '-') << "\n\n";

            if (inheritance.is_abstract) {
                ss << "[Abstract] ";
            }
            if (inheritance.is_polymorphic) {
                ss << "[Polymorphic] ";
            }
            ss << "\n\n";
        }

        static std::string to_anchor(const std::string &str) {
            std::string result;
            for (char c : str) {
                if (std::isalnum(c)) {
                    result += std::tolower(c);
                } else if (c == ' ' || c == '_') {
                    result += '-';
                }
            }
            return result;
        }
    };

} // namespace rosetta::extensions