#pragma once
#include "../CodeWriter.h"
#include <rosetta/rosetta.h>
#include <algorithm>
#include <regex>

// ============================================================================
// N-API C++ Code Generator - Uses Rosetta's native field/property separation
// ============================================================================

class JsGenerator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_helpers();
        write_class_wrappers();
        write_conversion_specializations();
        write_init_function();
    }

private:
    using ConstructorMeta = rosetta::core::Registry::MetadataHolder::ConstructorMeta;
    using MethodMeta = rosetta::core::Registry::MetadataHolder::MethodMeta;
    using PropertyMeta = rosetta::core::Registry::MetadataHolder::PropertyMeta;

    void write_header() {
        line("// ============================================================================");
        line("// AUTO-GENERATED N-API BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// Module: " + config_.module_name);
        line("// ============================================================================");
        line();
    }

    void write_includes() {
        line("#include <napi.h>");
        line("#include <memory>");
        line("#include <vector>");
        line("#include <string>");
        line("#include <stdexcept>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();
        
        if (!config_.source_headers.empty()) {
            line("// Project headers");
            for (const auto& header : config_.source_headers) {
                line("#include <" + header + ">");
            }
            line();
        }
        
        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
            line();
        }
    }

    void write_helpers() {
        line("// ============================================================================");
        line("// TypedArray <-> C++ conversion helpers");
        line("// ============================================================================");
        line();

        line("template<typename T>");
        line("Napi::Float64Array vectorToTypedArray(Napi::Env env, const std::vector<T>& vec) {");
        indent();
        line("auto arr = Napi::Float64Array::New(env, vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) {");
        indent();
        line("arr[i] = static_cast<double>(vec[i]);");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("inline std::vector<double> typedArrayToVectorDouble(const Napi::Float64Array& arr) {");
        indent();
        line("std::vector<double> vec(arr.ElementLength());");
        line("for (size_t i = 0; i < arr.ElementLength(); ++i) {");
        indent();
        line("vec[i] = arr[i];");
        dedent();
        line("}");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("inline std::vector<int> typedArrayToVectorInt(const Napi::Int32Array& arr) {");
        indent();
        line("std::vector<int> vec(arr.ElementLength());");
        line("for (size_t i = 0; i < arr.ElementLength(); ++i) {");
        indent();
        line("vec[i] = arr[i];");
        dedent();
        line("}");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("inline Napi::Int32Array vectorIntToTypedArray(Napi::Env env, const std::vector<int>& vec) {");
        indent();
        line("auto arr = Napi::Int32Array::New(env, vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) {");
        indent();
        line("arr[i] = vec[i];");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        // Forward declare wrapper classes
        line("// ============================================================================");
        line("// Forward declarations");
        line("// ============================================================================");
        line();
        auto& registry = rosetta::Registry::instance();
        for (const auto& name : registry.list_classes()) {
            if (!config_.should_skip_class(name)) {
                line("class " + name + "Wrapper;");
            }
        }
        line();

        // Forward declare type-specific conversion functions for each registered class
        line("// Type-specific conversion function declarations");
        line("// (Implementations defined after wrapper class definitions)");
        for (const auto& name : registry.list_classes()) {
            if (!config_.should_skip_class(name)) {
                auto* holder = registry.get_by_name(name);
                if (holder) {
                    std::string cpp_type = holder->get_cpp_type_name();
                    line("std::vector<" + cpp_type + "> jsArrayToVector_" + name + "(Napi::Env env, const Napi::Value& arr);");
                    line("Napi::Array vectorToJsArray_" + name + "(Napi::Env env, const std::vector<" + cpp_type + ">& vec);");
                    line(cpp_type + " unwrapObject_" + name + "(const Napi::Value& val);");
                    line("Napi::Value wrapObject_" + name + "(Napi::Env env, const " + cpp_type + "& val);");
                }
            }
        }
        line();
    }

    void write_class_wrappers() {
        line("// ============================================================================");
        line("// Class Wrapper Definitions");
        line("// ============================================================================");
        line();

        auto& registry = rosetta::Registry::instance();
        auto class_names = registry.list_classes();

        for (const auto& name : class_names) {
            auto* holder = registry.get_by_name(name);
            if (holder && !config_.should_skip_class(name)) {
                write_class_wrapper(name, holder);
            }
        }
    }

    void write_class_wrapper(const std::string& name,
                             const rosetta::core::Registry::MetadataHolder* holder) {
        std::string cpp_type = holder->get_cpp_type_name();
        std::string wrapper_name = name + "Wrapper";

        line("// --- " + name + " ---");
        line("class " + wrapper_name + " : public Napi::ObjectWrap<" + wrapper_name + "> {");
        line("public:");
        indent();

        // Static constructor reference for creating instances
        line("static Napi::FunctionReference constructor;");
        line();

        // Static Init method
        line("static Napi::Object Init(Napi::Env env, Napi::Object exports) {");
        indent();
        line("Napi::Function func = DefineClass(env, \"" + name + "\", {");
        indent();

        std::vector<std::string> members;
        
        // Fields (actual C++ member fields)
        for (const auto& field : holder->get_fields()) {
            if (!config_.should_skip_method(name, field)) {
                members.push_back("InstanceAccessor<&" + wrapper_name + "::GetField_" + field + 
                                 ", &" + wrapper_name + "::SetField_" + field + ">(\"" + field + "\")");
            }
        }

        // Properties (virtual fields via getter/setter) - using new Rosetta API!
        for (const auto& prop_name : holder->get_properties()) {
            if (!config_.should_skip_method(name, prop_name)) {
                auto prop_info = holder->get_property_info(prop_name);
                if (prop_info.is_readonly) {
                    members.push_back("InstanceAccessor<&" + wrapper_name + "::GetProp_" + prop_name + 
                                     ">(\"" + prop_name + "\")");
                } else {
                    members.push_back("InstanceAccessor<&" + wrapper_name + "::GetProp_" + prop_name + 
                                     ", &" + wrapper_name + "::SetProp_" + prop_name + ">(\"" + prop_name + "\")");
                }
            }
        }
        
        // Methods
        for (const auto& m : holder->get_methods()) {
            if (!config_.should_skip_method(name, m)) {
                members.push_back("InstanceMethod<&" + wrapper_name + "::" + m + ">(\"" + m + "\")");
            }
        }

        for (size_t i = 0; i < members.size(); ++i) {
            std::string comma = (i < members.size() - 1) ? "," : "";
            line(members[i] + comma);
        }

        dedent();
        line("});");
        line();
        line("constructor = Napi::Persistent(func);");
        line("constructor.SuppressDestruct();");
        line();
        line("exports.Set(\"" + name + "\", func);");
        line("return exports;");
        dedent();
        line("}");
        line();

        // Constructor
        write_constructor(wrapper_name, cpp_type, holder);

        line("std::shared_ptr<" + cpp_type + "> GetInstance() { return instance_; }");
        line();

        // Generate field accessors
        for (const auto& field : holder->get_fields()) {
            if (!config_.should_skip_method(name, field)) {
                write_field_accessors(cpp_type, field, holder);
            }
        }

        // Generate property accessors (using new Rosetta API)
        for (const auto& prop_name : holder->get_properties()) {
            if (!config_.should_skip_method(name, prop_name)) {
                auto prop_info = holder->get_property_info(prop_name);
                write_property_accessors(cpp_type, prop_info, holder);
            }
        }

        // Generate method wrappers
        for (const auto& m : holder->get_methods()) {
            if (!config_.should_skip_method(name, m)) {
                write_method_wrapper(cpp_type, m, holder);
            }
        }

        dedent();
        line("private:");
        indent();
        line("std::shared_ptr<" + cpp_type + "> instance_;");
        dedent();
        line("};");
        line();
    }

    void write_constructor(const std::string& wrapper_name,
                           const std::string& cpp_type,
                           const rosetta::core::Registry::MetadataHolder* holder) {
        line(wrapper_name + "(const Napi::CallbackInfo& info)");
        line("    : Napi::ObjectWrap<" + wrapper_name + ">(info) {");
        indent();
        line("Napi::Env env = info.Env();");
        
        auto ctors = holder->get_constructors();
        if (ctors.empty()) {
            line("instance_ = std::make_shared<" + cpp_type + ">();");
        } else {
            line("size_t argc = info.Length();");
            line();
            
            bool first = true;
            for (const auto& ctor : ctors) {
                auto params = ctor.get_param_types();
                std::string condition = first ? "if" : "} else if";
                first = false;
                
                line(condition + " (argc == " + std::to_string(params.size()) + ") {");
                indent();
                
                if (params.empty()) {
                    line("instance_ = std::make_shared<" + cpp_type + ">();");
                } else {
                    std::vector<std::string> args;
                    for (size_t i = 0; i < params.size(); ++i) {
                        std::string arg = generate_arg_extraction(params[i], i);
                        args.push_back(arg);
                    }
                    line("instance_ = std::make_shared<" + cpp_type + ">(" + join(args, ", ") + ");");
                }
                dedent();
            }
            line("} else {");
            indent();
            line("Napi::TypeError::New(env, \"Invalid number of arguments\").ThrowAsJavaScriptException();");
            dedent();
            line("}");
        }
        
        dedent();
        line("}");
        line();
    }

    void write_field_accessors(const std::string& cpp_type,
                               const std::string& field_name,
                               const rosetta::core::Registry::MetadataHolder* holder) {
        std::type_index field_type = holder->get_field_type(field_name);
        std::string type_str = rosetta::demangle(field_type.name());
        
        // Getter
        line("Napi::Value GetField_" + field_name + "(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("return " + generate_return_conversion(type_str, "instance_->" + field_name) + ";");
        dedent();
        line("}");
        line();

        // Setter
        line("void SetField_" + field_name + "(const Napi::CallbackInfo& info, const Napi::Value& value) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("instance_->" + field_name + " = " + generate_value_extraction(type_str, "value") + ";");
        dedent();
        line("}");
        line();
    }

    void write_property_accessors(const std::string& cpp_type,
                                  const PropertyMeta& prop,
                                  const rosetta::core::Registry::MetadataHolder* holder) {
        std::string type_str = prop.get_value_type_str();
        std::string cap_name = capitalize(prop.name);
        
        // Getter - calls the C++ getter method
        line("Napi::Value GetProp_" + prop.name + "(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("return " + generate_return_conversion(type_str, "instance_->get" + cap_name + "()") + ";");
        dedent();
        line("}");
        line();

        // Setter - calls the C++ setter method (only if not read-only)
        if (!prop.is_readonly) {
            line("void SetProp_" + prop.name + "(const Napi::CallbackInfo& info, const Napi::Value& value) {");
            indent();
            line("Napi::Env env = info.Env();");
            line("instance_->set" + cap_name + "(" + generate_value_extraction(type_str, "value") + ");");
            dedent();
            line("}");
            line();
        }
    }

    void write_method_wrapper(const std::string& cpp_type,
                              const std::string& method_name,
                              const rosetta::core::Registry::MetadataHolder* holder) {
        auto info = holder->get_method_info(method_name);
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        line("Napi::Value " + method_name + "(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line();

        if (!param_types.empty()) {
            line("if (info.Length() < " + std::to_string(param_types.size()) + ") {");
            indent();
            line("Napi::TypeError::New(env, \"Wrong number of arguments\").ThrowAsJavaScriptException();");
            line("return env.Undefined();");
            dedent();
            line("}");
            line();
        }

        std::vector<std::string> args;
        for (size_t i = 0; i < param_types.size(); ++i) {
            std::string arg = generate_arg_extraction(param_types[i], i);
            args.push_back(arg);
        }

        if (return_type == "void") {
            line("instance_->" + method_name + "(" + join(args, ", ") + ");");
            line("return env.Undefined();");
        } else {
            line("auto result = instance_->" + method_name + "(" + join(args, ", ") + ");");
            line("return " + generate_return_conversion(return_type, "result") + ";");
        }

        dedent();
        line("}");
        line();
    }

    void write_conversion_specializations() {
        line("// ============================================================================");
        line("// Static Member Definitions for Wrapper Classes");
        line("// ============================================================================");
        line();
        
        auto& registry = rosetta::Registry::instance();
        auto class_names = registry.list_classes();

        // Define static constructor members
        for (const auto& name : class_names) {
            if (config_.should_skip_class(name)) continue;
            std::string wrapper_name = name + "Wrapper";
            line("Napi::FunctionReference " + wrapper_name + "::constructor;");
        }
        line();

        line("// ============================================================================");
        line("// Type-Specific Conversion Function Implementations");
        line("// ============================================================================");
        line();

        for (const auto& name : class_names) {
            if (config_.should_skip_class(name)) continue;
            auto* holder = registry.get_by_name(name);
            if (!holder) continue;
            
            std::string cpp_type = holder->get_cpp_type_name();
            std::string wrapper_name = name + "Wrapper";
            
            // jsArrayToVector_ClassName
            line("std::vector<" + cpp_type + "> jsArrayToVector_" + name + "(Napi::Env env, const Napi::Value& val) {");
            indent();
            line("if (!val.IsArray()) {");
            indent();
            line("throw std::runtime_error(\"Expected an array for std::vector<" + name + ">\");");
            dedent();
            line("}");
            line("Napi::Array arr = val.As<Napi::Array>();");
            line("std::vector<" + cpp_type + "> result;");
            line("result.reserve(arr.Length());");
            line("for (uint32_t i = 0; i < arr.Length(); ++i) {");
            indent();
            line("Napi::Value elem = arr.Get(i);");
            line("if (elem.IsObject()) {");
            indent();
            line(wrapper_name + "* wrapper = Napi::ObjectWrap<" + wrapper_name + ">::Unwrap(elem.As<Napi::Object>());");
            line("if (wrapper && wrapper->GetInstance()) {");
            indent();
            line("result.push_back(*(wrapper->GetInstance()));");
            dedent();
            line("}");
            dedent();
            line("}");
            dedent();
            line("}");
            line("return result;");
            dedent();
            line("}");
            line();
            
            // vectorToJsArray_ClassName
            line("Napi::Array vectorToJsArray_" + name + "(Napi::Env env, const std::vector<" + cpp_type + ">& vec) {");
            indent();
            line("Napi::Array arr = Napi::Array::New(env, vec.size());");
            line("for (size_t i = 0; i < vec.size(); ++i) {");
            indent();
            line("Napi::Object obj = " + wrapper_name + "::constructor.New({});");
            line(wrapper_name + "* wrapper = Napi::ObjectWrap<" + wrapper_name + ">::Unwrap(obj);");
            line("if (wrapper && wrapper->GetInstance()) {");
            indent();
            line("*(wrapper->GetInstance()) = vec[i];");
            dedent();
            line("}");
            line("arr.Set(i, obj);");
            dedent();
            line("}");
            line("return arr;");
            dedent();
            line("}");
            line();
            
            // unwrapObject_ClassName
            line(cpp_type + " unwrapObject_" + name + "(const Napi::Value& val) {");
            indent();
            line("if (!val.IsObject()) {");
            indent();
            line("throw std::runtime_error(\"Expected object for " + name + "\");");
            dedent();
            line("}");
            line(wrapper_name + "* wrapper = Napi::ObjectWrap<" + wrapper_name + ">::Unwrap(val.As<Napi::Object>());");
            line("if (!wrapper || !wrapper->GetInstance()) {");
            indent();
            line("throw std::runtime_error(\"Invalid " + name + " object\");");
            dedent();
            line("}");
            line("return *(wrapper->GetInstance());");
            dedent();
            line("}");
            line();
            
            // wrapObject_ClassName
            line("Napi::Value wrapObject_" + name + "(Napi::Env env, const " + cpp_type + "& val) {");
            indent();
            line("Napi::Object obj = " + wrapper_name + "::constructor.New({});");
            line(wrapper_name + "* wrapper = Napi::ObjectWrap<" + wrapper_name + ">::Unwrap(obj);");
            line("if (wrapper && wrapper->GetInstance()) {");
            indent();
            line("*(wrapper->GetInstance()) = val;");
            dedent();
            line("}");
            line("return obj;");
            dedent();
            line("}");
            line();
        }
    }

    void write_init_function() {
        line("// ============================================================================");
        line("// Module Initialization");
        line("// ============================================================================");
        line();

        line("Napi::Value ListClasses(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("auto classes = rosetta::Registry::instance().list_classes();");
        line("auto arr = Napi::Array::New(env, classes.size());");
        line("for (size_t i = 0; i < classes.size(); ++i) {");
        indent();
        line("arr.Set(i, Napi::String::New(env, classes[i]));");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("Napi::Value GetClassMethods(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("if (info.Length() < 1 || !info[0].IsString()) {");
        indent();
        line("Napi::TypeError::New(env, \"String expected\").ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("std::string name = info[0].As<Napi::String>().Utf8Value();");
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) {");
        indent();
        line("Napi::Error::New(env, \"Class not found: \" + name).ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("auto methods = h->get_methods();");
        line("auto arr = Napi::Array::New(env, methods.size());");
        line("for (size_t i = 0; i < methods.size(); ++i) {");
        indent();
        line("arr.Set(i, Napi::String::New(env, methods[i]));");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("Napi::Value GetClassFields(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("if (info.Length() < 1 || !info[0].IsString()) {");
        indent();
        line("Napi::TypeError::New(env, \"String expected\").ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("std::string name = info[0].As<Napi::String>().Utf8Value();");
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) {");
        indent();
        line("Napi::Error::New(env, \"Class not found: \" + name).ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("auto fields = h->get_fields();");
        line("auto arr = Napi::Array::New(env, fields.size());");
        line("for (size_t i = 0; i < fields.size(); ++i) {");
        indent();
        line("arr.Set(i, Napi::String::New(env, fields[i]));");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("Napi::Value GetClassProperties(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("if (info.Length() < 1 || !info[0].IsString()) {");
        indent();
        line("Napi::TypeError::New(env, \"String expected\").ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("std::string name = info[0].As<Napi::String>().Utf8Value();");
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) {");
        indent();
        line("Napi::Error::New(env, \"Class not found: \" + name).ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("auto properties = h->get_properties();");
        line("auto arr = Napi::Array::New(env, properties.size());");
        line("for (size_t i = 0; i < properties.size(); ++i) {");
        indent();
        line("arr.Set(i, Napi::String::New(env, properties[i]));");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("Napi::Value Version(const Napi::CallbackInfo& info) {");
        indent();
        line("return Napi::String::New(info.Env(), rosetta::version());");
        dedent();
        line("}");
        line();

        line("Napi::Object Init(Napi::Env env, Napi::Object exports) {");
        indent();
        
        if (!config_.registration_function.empty()) {
            line("// Register classes with Rosetta");
            line(config_.get_registration_call() + ";");
            line();
        }

        auto& registry = rosetta::Registry::instance();
        for (const auto& name : registry.list_classes()) {
            if (!config_.should_skip_class(name)) {
                line(name + "Wrapper::Init(env, exports);");
            }
        }
        line();

        line("exports.Set(\"listClasses\", Napi::Function::New(env, ListClasses));");
        line("exports.Set(\"getClassMethods\", Napi::Function::New(env, GetClassMethods));");
        line("exports.Set(\"getClassFields\", Napi::Function::New(env, GetClassFields));");
        line("exports.Set(\"getClassProperties\", Napi::Function::New(env, GetClassProperties));");
        line("exports.Set(\"version\", Napi::Function::New(env, Version));");
        line();
        line("return exports;");
        dedent();
        line("}");
        line();

        line("NODE_API_MODULE(" + config_.module_name + ", Init)");
    }

    // Helper methods
    std::string capitalize(const std::string& s) {
        if (s.empty()) return s;
        std::string result = s;
        result[0] = std::toupper(result[0]);
        return result;
    }

    // Normalize type string - remove std::__1::, allocators, const, &, etc.
    std::string normalize_type(const std::string& t) {
        std::string r = t;
        
        // Remove std::__1:: (libc++ internal namespace)
        size_t pos;
        while ((pos = r.find("std::__1::")) != std::string::npos) {
            r.replace(pos, 10, "std::");
        }
        
        // Remove allocator template arguments
        // e.g., std::vector<Surface, std::allocator<Surface>> -> std::vector<Surface>
        std::regex alloc_regex(",\\s*std::allocator<[^>]+>");
        r = std::regex_replace(r, alloc_regex, "");
        
        // Remove const (prefix form: "const ")
        while ((pos = r.find("const ")) != std::string::npos) r.erase(pos, 6);
        // Remove const (postfix form: " const")
        while ((pos = r.find(" const")) != std::string::npos) r.erase(pos, 6);
        // Remove & and *
        while ((pos = r.find("&")) != std::string::npos) r.erase(pos, 1);
        while ((pos = r.find("*")) != std::string::npos) r.erase(pos, 1);
        
        // Trim whitespace
        while (!r.empty() && r[0] == ' ') r.erase(0, 1);
        while (!r.empty() && r.back() == ' ') r.pop_back();
        
        return r;
    }

    // Check if type is a vector (handles various forms)
    bool is_vector_type(const std::string& type) {
        std::string norm = normalize_type(type);
        return norm.find("vector<") != std::string::npos ||
               norm.find("std::vector<") != std::string::npos;
    }

    // Extract element type from vector
    std::string extract_vector_element_type(const std::string& type) {
        std::string norm = normalize_type(type);
        
        size_t start = norm.find("vector<");
        if (start == std::string::npos) return "";
        start += 7; // skip "vector<"
        
        // Find matching >
        int depth = 1;
        size_t end = start;
        while (end < norm.size() && depth > 0) {
            if (norm[end] == '<') depth++;
            else if (norm[end] == '>') depth--;
            if (depth > 0) end++;
        }
        
        std::string elem = norm.substr(start, end - start);
        // Trim whitespace
        while (!elem.empty() && elem[0] == ' ') elem.erase(0, 1);
        while (!elem.empty() && elem.back() == ' ') elem.pop_back();
        
        return elem;
    }

    // Check if a type is a registered class
    bool is_registered_class(const std::string& type_name) {
        auto& registry = rosetta::Registry::instance();
        // Try the type name directly and also without namespace
        if (registry.get_by_name(type_name) != nullptr) return true;
        
        // Try stripping namespace
        size_t pos = type_name.rfind("::");
        if (pos != std::string::npos) {
            std::string short_name = type_name.substr(pos + 2);
            if (registry.get_by_name(short_name) != nullptr) return true;
        }
        return false;
    }

    // Get wrapper class name for a registered type
    std::string get_wrapper_name(const std::string& type_name) {
        // Strip namespace if present
        size_t pos = type_name.rfind("::");
        std::string short_name = (pos != std::string::npos) 
            ? type_name.substr(pos + 2) 
            : type_name;
        return short_name + "Wrapper";
    }

    std::string generate_arg_extraction(const std::string& type, size_t index) {
        std::string idx = std::to_string(index);
        std::string norm = normalize_type(type);
        
        // Handle std::function types
        if (is_function_type(norm)) {
            return generate_function_arg_extraction(type, index);
        }
        
        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "typedArrayToVectorDouble(info[" + idx + "].As<Napi::Float64Array>())";
            }
            if (elem == "int") {
                return "typedArrayToVectorInt(info[" + idx + "].As<Napi::Int32Array>())";
            }
            // For vectors of registered classes, use named helper function
            if (is_registered_class(elem)) {
                std::string simple_name = get_simple_type_name(elem);
                return "jsArrayToVector_" + simple_name + "(info.Env(), info[" + idx + "])";
            }
        }
        
        if (norm.find("string") != std::string::npos) {
            return "info[" + idx + "].As<Napi::String>().Utf8Value()";
        }
        if (norm == "bool") {
            return "info[" + idx + "].As<Napi::Boolean>().Value()";
        }
        if (norm == "int" || norm == "long" || norm == "size_t") {
            return "info[" + idx + "].As<Napi::Number>().Int32Value()";
        }
        if (norm == "float" || norm == "double") {
            return "info[" + idx + "].As<Napi::Number>().DoubleValue()";
        }
        
        // For registered class types passed by value
        if (is_registered_class(norm)) {
            std::string simple_name = get_simple_type_name(norm);
            return "unwrapObject_" + simple_name + "(info[" + idx + "])";
        }
        
        return "info[" + idx + "].As<Napi::Number>().DoubleValue()";
    }

    // Get simple type name (strip namespace)
    std::string get_simple_type_name(const std::string& type) {
        std::string norm = normalize_type(type);
        size_t pos = norm.rfind("::");
        if (pos != std::string::npos) {
            return norm.substr(pos + 2);
        }
        return norm;
    }

    // Check if type is a std::function
    bool is_function_type(const std::string& type) {
        std::string norm = normalize_type(type);
        return norm.find("function<") != std::string::npos ||
               norm.find("std::function<") != std::string::npos;
    }

    // Extract function signature from std::function<ReturnType(ParamTypes...)>
    struct FunctionSignature {
        std::string return_type;
        std::vector<std::string> param_types;
    };

    FunctionSignature extract_function_signature(const std::string& type) {
        FunctionSignature sig;
        std::string norm = normalize_type(type);
        
        // Find "function<"
        size_t start = norm.find("function<");
        if (start == std::string::npos) return sig;
        start += 9; // skip "function<"
        
        // Find the return type (everything before the '(')
        size_t paren_start = norm.find('(', start);
        if (paren_start == std::string::npos) return sig;
        
        sig.return_type = norm.substr(start, paren_start - start);
        // Trim whitespace
        while (!sig.return_type.empty() && sig.return_type[0] == ' ') 
            sig.return_type.erase(0, 1);
        while (!sig.return_type.empty() && sig.return_type.back() == ' ') 
            sig.return_type.pop_back();
        
        // Find the closing paren
        size_t paren_end = norm.find(')', paren_start);
        if (paren_end == std::string::npos) return sig;
        
        // Extract parameter types
        std::string params_str = norm.substr(paren_start + 1, paren_end - paren_start - 1);
        
        // Split by comma, accounting for nested templates
        if (!params_str.empty()) {
            int depth = 0;
            size_t last_start = 0;
            for (size_t i = 0; i <= params_str.size(); ++i) {
                if (i == params_str.size() || (params_str[i] == ',' && depth == 0)) {
                    std::string param = params_str.substr(last_start, i - last_start);
                    // Trim whitespace and remove const/&
                    param = normalize_type(param);
                    if (!param.empty()) {
                        sig.param_types.push_back(param);
                    }
                    last_start = i + 1;
                } else if (params_str[i] == '<') {
                    depth++;
                } else if (params_str[i] == '>') {
                    depth--;
                }
            }
        }
        
        return sig;
    }

    // Generate conversion code for std::function from JavaScript function
    std::string generate_function_arg_extraction(const std::string& type, size_t index) {
        std::string idx = std::to_string(index);
        auto sig = extract_function_signature(type);
        
        if (sig.return_type.empty()) {
            // Fallback if parsing failed
            return "info[" + idx + "]";
        }
        
        std::ostringstream oss;
        
        // Create a lambda that wraps the JavaScript function
        // Use shared_ptr to make the lambda copyable (required by std::function)
        // FunctionReference is not copyable, so we wrap it in shared_ptr
        oss << "[fn = std::make_shared<Napi::FunctionReference>(Napi::Persistent(info[" << idx << "].As<Napi::Function>())), env = info.Env()](";
        
        // Generate parameter list
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << "const " << sig.param_types[i] << "& p" << i;
        }
        oss << ") -> " << sig.return_type << " {\n";
        
        // Convert C++ parameters to Napi::Value
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            std::string param_type = sig.param_types[i];
            std::string simple_name = get_simple_type_name(param_type);
            if (is_registered_class(param_type)) {
                oss << "                Napi::Value arg" << i << " = wrapObject_" << simple_name << "(env, p" << i << ");\n";
            } else if (param_type == "double" || param_type == "float") {
                oss << "                Napi::Value arg" << i << " = Napi::Number::New(env, p" << i << ");\n";
            } else if (param_type == "int" || param_type == "long" || param_type == "size_t") {
                oss << "                Napi::Value arg" << i << " = Napi::Number::New(env, p" << i << ");\n";
            } else if (param_type == "bool") {
                oss << "                Napi::Value arg" << i << " = Napi::Boolean::New(env, p" << i << ");\n";
            } else if (param_type.find("string") != std::string::npos) {
                oss << "                Napi::Value arg" << i << " = Napi::String::New(env, p" << i << ");\n";
            } else {
                oss << "                Napi::Value arg" << i << " = wrapObject_" << simple_name << "(env, p" << i << ");\n";
            }
        }
        
        // Call the JavaScript function via the shared_ptr
        oss << "                Napi::Value result = fn->Call({";
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << "arg" << i;
        }
        oss << "});\n";
        
        // Convert result back to C++
        std::string return_simple_name = get_simple_type_name(sig.return_type);
        if (is_registered_class(sig.return_type)) {
            oss << "                return unwrapObject_" << return_simple_name << "(result);\n";
        } else if (sig.return_type == "double" || sig.return_type == "float") {
            oss << "                return result.As<Napi::Number>().DoubleValue();\n";
        } else if (sig.return_type == "int" || sig.return_type == "long" || sig.return_type == "size_t") {
            oss << "                return result.As<Napi::Number>().Int32Value();\n";
        } else if (sig.return_type == "bool") {
            oss << "                return result.As<Napi::Boolean>().Value();\n";
        } else if (sig.return_type.find("string") != std::string::npos) {
            oss << "                return result.As<Napi::String>().Utf8Value();\n";
        } else {
            oss << "                return unwrapObject_" << return_simple_name << "(result);\n";
        }
        
        oss << "            }";
        
        return oss.str();
    }

    std::string generate_value_extraction(const std::string& type, const std::string& var) {
        std::string norm = normalize_type(type);
        
        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "typedArrayToVectorDouble(" + var + ".As<Napi::Float64Array>())";
            }
            if (elem == "int") {
                return "typedArrayToVectorInt(" + var + ".As<Napi::Int32Array>())";
            }
            // For vectors of registered classes
            if (is_registered_class(elem)) {
                std::string simple_name = get_simple_type_name(elem);
                return "jsArrayToVector_" + simple_name + "(env, " + var + ")";
            }
        }
        
        if (norm.find("string") != std::string::npos) {
            return var + ".As<Napi::String>().Utf8Value()";
        }
        if (norm == "bool") {
            return var + ".As<Napi::Boolean>().Value()";
        }
        if (norm == "int" || norm == "long" || norm == "size_t") {
            return var + ".As<Napi::Number>().Int32Value()";
        }
        if (norm == "float" || norm == "double") {
            return var + ".As<Napi::Number>().DoubleValue()";
        }
        
        // For registered class types
        if (is_registered_class(norm)) {
            std::string simple_name = get_simple_type_name(norm);
            return "unwrapObject_" + simple_name + "(" + var + ")";
        }
        
        return var + ".As<Napi::Number>().DoubleValue()";
    }

    std::string generate_return_conversion(const std::string& type, const std::string& var) {
        std::string norm = normalize_type(type);
        
        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "vectorToTypedArray(env, " + var + ")";
            }
            if (elem == "int") {
                return "vectorIntToTypedArray(env, " + var + ")";
            }
            // For vectors of registered classes
            if (is_registered_class(elem)) {
                std::string simple_name = get_simple_type_name(elem);
                return "vectorToJsArray_" + simple_name + "(env, " + var + ")";
            }
        }
        
        if (norm.find("string") != std::string::npos) {
            return "Napi::String::New(env, " + var + ")";
        }
        if (norm == "bool") {
            return "Napi::Boolean::New(env, " + var + ")";
        }
        if (norm == "int" || norm == "long" || norm == "size_t" ||
            norm == "float" || norm == "double") {
            return "Napi::Number::New(env, " + var + ")";
        }
        if (norm == "void") {
            return "env.Undefined()";
        }
        
        // For registered class types
        if (is_registered_class(norm)) {
            std::string simple_name = get_simple_type_name(norm);
            return "wrapObject_" + simple_name + "(env, " + var + ")";
        }
        
        return "Napi::Number::New(env, " + var + ")";
    }
};
