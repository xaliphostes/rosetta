#pragma once
#include "../common/CodeWriter.h"
#include <algorithm>
#include <map>
#include <rosetta/core/function_registry.h>
#include <rosetta/rosetta.h>
#include <typeindex>

// ============================================================================
// N-API Code Generator - Modernized with emit() and block helpers
// ============================================================================
// UPDATED: Properly handles overloaded and aliased free functions.
//
// Free function binding strategy:
// - Non-overloaded: exports.Set("name", Napi::Function::New(env, Func_name));
// - Overloaded:     Uses wrapper function with explicit type handling
// - Aliased:        exports.Set("alias", Napi::Function::New(env, Func_cpp_name));
//
// The is_overloaded() flag from FunctionMetadata determines which form to use.
// ============================================================================

class JsGenerator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_typed_array_helpers();
        write_forward_declarations();
        write_class_wrappers();
        write_conversion_implementations();
        write_free_functions();
        write_utility_functions();
        write_init_function();
    }

private:
    using ConstructorMeta = rosetta::core::Registry::MetadataHolder::ConstructorMeta;
    using MethodMeta      = rosetta::core::Registry::MetadataHolder::MethodMeta;
    using PropertyMeta    = rosetta::core::Registry::MetadataHolder::PropertyMeta;

    // Set of Python-specific dunder methods to skip
    const std::set<std::string> python_dunder_methods_ = {
        "__repr__", "__str__",     "__len__",      "__getitem__", "__setitem__",  "__delitem__",
        "__iter__", "__next__",    "__contains__", "__add__",     "__sub__",      "__mul__",
        "__div__",  "__truediv__", "__floordiv__", "__mod__",     "__pow__",      "__and__",
        "__or__",   "__xor__",     "__lshift__",   "__rshift__",  "__neg__",      "__pos__",
        "__abs__",  "__invert__",  "__eq__",       "__ne__",      "__lt__",       "__le__",
        "__gt__",   "__ge__",      "__hash__",     "__bool__",    "__call__",     "__enter__",
        "__exit__", "__radd__",    "__rsub__",     "__rmul__",    "__rtruediv__", "__iadd__",
        "__isub__", "__imul__",    "__itruediv__", "__copy__",    "__deepcopy__"};

    // Track classes that should not have vector conversion (abstract or non-copyable)
    mutable std::set<std::string> skip_vector_conversion_;

    bool is_python_dunder_method(const std::string &method_name) const {
        return python_dunder_methods_.find(method_name) != python_dunder_methods_.end();
    }

    void write_header() {
        emit(R"(
// ============================================================================
// AUTO-GENERATED N-API BINDINGS - DO NOT EDIT
// Generated by binding_generator from Rosetta introspection
// ============================================================================
)");
    }

    void write_includes() {
        emit(R"(
#include <napi.h>
#include <memory>
#include <vector>
#include <string>
#include <stdexcept>
#include <functional>

#include <rosetta/rosetta.h>

// Project headers
)");

        for (const auto &header : config_.source_headers) {
            line("#include <" + header + ">");
        }
        blank();

        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
        }
        blank();
    }

    void write_typed_array_helpers() {
        emit(R"(
// ============================================================================
// TypedArray <-> C++ conversion helpers
// ============================================================================
namespace {

template<typename T>
Napi::Float64Array vectorToTypedArray(Napi::Env env, const std::vector<T>& vec) {
    auto arr = Napi::Float64Array::New(env, vec.size());
    for (size_t i = 0; i < vec.size(); ++i) {
        arr[i] = static_cast<double>(vec[i]);
    }
    return arr;
}

std::vector<double> typedArrayToVectorDouble(const Napi::Float64Array& arr) {
    std::vector<double> vec(arr.ElementLength());
    for (size_t i = 0; i < arr.ElementLength(); ++i) {
        vec[i] = arr[i];
    }
    return vec;
}

std::vector<int> typedArrayToVectorInt(const Napi::Int32Array& arr) {
    std::vector<int> vec(arr.ElementLength());
    for (size_t i = 0; i < arr.ElementLength(); ++i) {
        vec[i] = arr[i];
    }
    return vec;
}

Napi::Int32Array vectorIntToTypedArray(Napi::Env env, const std::vector<int>& vec) {
    auto arr = Napi::Int32Array::New(env, vec.size());
    for (size_t i = 0; i < vec.size(); ++i) {
        arr[i] = vec[i];
    }
    return arr;
}

} // anonymous namespace
)");
    }

    void write_forward_declarations() {
        emit(R"(
// ============================================================================
// Forward Declarations
// ============================================================================
)");

        auto &registry = rosetta::Registry::instance();
        for (const auto &name : registry.list_classes()) {
            if (!config_.should_skip_class(name)) {
                std::string simple_name = get_simple_class_name(name);
                line("class " + simple_name + "Wrapper;");
            }
        }
        blank();

        line("// Type-specific conversion function declarations");
        for (const auto &name : registry.list_classes()) {
            if (config_.should_skip_class(name))
                continue;

            auto *holder = registry.get_by_name(name);
            if (!holder)
                continue;

            std::string cpp_type  = holder->get_cpp_type_name();
            std::string safe_name = make_safe_identifier(name);

            // Check if this class should skip vector conversion
            bool has_default_ctor = false;
            auto ctors            = holder->get_constructors();
            for (const auto &ctor : ctors) {
                if (ctor.get_param_types().empty()) {
                    has_default_ctor = true;
                    break;
                }
            }

            if (has_default_ctor) {
                line("std::vector<" + cpp_type + "> jsArrayToVector_" + safe_name +
                     "(Napi::Env env, const Napi::Value& arr);");
                line("Napi::Array vectorToJsArray_" + safe_name + "(Napi::Env env, const std::vector<" +
                     cpp_type + ">& vec);");
            } else {
                skip_vector_conversion_.insert(name);
                line("// Skipped vector conversion for " + name +
                     " (no default constructor or abstract/non-copyable)");
            }

            line("std::shared_ptr<" + cpp_type + "> unwrapObjectPtr_" + safe_name +
                 "(const Napi::Value& val);");
            line("Napi::Value wrapObjectPtr_" + safe_name + "(Napi::Env env, std::shared_ptr<" +
                 cpp_type + "> val);");
        }
        blank();
    }

    void write_class_wrappers() {
        emit(R"(
// ============================================================================
// Class Wrapper Definitions
// ============================================================================
)");

        auto &registry    = rosetta::Registry::instance();
        auto  class_names = registry.list_classes();
        auto  sorted      = topological_sort(class_names, registry);

        for (const auto &name : sorted) {
            auto *holder = registry.get_by_name(name);
            if (holder && !config_.should_skip_class(name)) {
                write_class_wrapper(name, holder);
            }
        }
    }

    std::vector<std::string> topological_sort(const std::vector<std::string> &names,
                                              rosetta::Registry              &registry) {
        std::vector<std::string> sorted;
        std::set<std::string>    visited;
        std::set<std::string>    name_set(names.begin(), names.end());

        std::map<std::string, std::string> short_to_full;
        for (const auto &n : names) {
            size_t      pos           = n.rfind("::");
            std::string short_name    = (pos != std::string::npos) ? n.substr(pos + 2) : n;
            short_to_full[short_name] = n;
        }

        std::function<void(const std::string &)> visit = [&](const std::string &n) {
            if (visited.count(n))
                return;
            visited.insert(n);
            auto *h = registry.get_by_name(n);
            if (h) {
                auto base = h->get_base_class();
                if (!base.empty()) {
                    if (name_set.count(base)) {
                        visit(base);
                    } else {
                        size_t      pos = base.rfind("::");
                        std::string base_short =
                            (pos != std::string::npos) ? base.substr(pos + 2) : base;
                        auto it = short_to_full.find(base_short);
                        if (it != short_to_full.end() && name_set.count(it->second)) {
                            visit(it->second);
                        }
                    }
                }
            }
            sorted.push_back(n);
        };

        for (const auto &n : names)
            visit(n);
        return sorted;
    }

    void write_class_wrapper(const std::string                             &name,
                             const rosetta::core::Registry::MetadataHolder *holder) {
        std::string cpp_type      = holder->get_cpp_type_name();
        std::string simple_name   = get_simple_class_name(name);
        std::string wrapper_name  = simple_name + "Wrapper";
        std::string js_class_name = simple_name;

        line("// --- " + simple_name + " ---");
        line("class " + wrapper_name + " : public Napi::ObjectWrap<" + wrapper_name + "> {");
        line("public:");

        with_indent([&]() {
            line("static Napi::FunctionReference constructor;");
            blank();

            // Init method
            write_class_init(name, holder, wrapper_name, js_class_name);

            // Constructor
            write_constructor(wrapper_name, cpp_type, holder);

            // Instance getter/setter
            line("std::shared_ptr<" + cpp_type + "> GetInstance() { return instance_; }");
            line("void SetInstance(std::shared_ptr<" + cpp_type + "> inst) { instance_ = inst; }");
            blank();

            // Field accessors
            for (const auto &field : holder->get_fields()) {
                if (!config_.should_skip_method(name, field)) {
                    write_field_accessors(cpp_type, field, holder);
                }
            }

            // Property accessors
            for (const auto &prop_name : holder->get_properties()) {
                if (!config_.should_skip_method(name, prop_name)) {
                    auto prop_info = holder->get_property_info(prop_name);
                    write_property_accessors(cpp_type, prop_info, holder);
                }
            }

            // Method wrappers
            auto                  fields     = holder->get_fields();
            auto                  properties = holder->get_properties();
            std::set<std::string> field_set(fields.begin(), fields.end());
            std::set<std::string> prop_set(properties.begin(), properties.end());

            for (const auto &m : holder->get_methods()) {
                if (field_set.find(m) != field_set.end())
                    continue;
                if (prop_set.find(m) != prop_set.end())
                    continue;
                if (!config_.should_skip_method(name, m) && !is_python_dunder_method(m)) {
                    write_method_wrapper(cpp_type, m, holder);
                }
            }
        });

        line("private:");
        with_indent([&]() { line("std::shared_ptr<" + cpp_type + "> instance_;"); });
        line("};");
        blank();
    }

    void write_class_init(const std::string                             &name,
                          const rosetta::core::Registry::MetadataHolder *holder,
                          const std::string &wrapper_name, const std::string &js_class_name) {
        line("static Napi::Object Init(Napi::Env env, Napi::Object exports) {");
        with_indent([&]() {
            line("Napi::Function func = DefineClass(env, \"" + js_class_name + "\", {");

            with_indent([&]() {
                std::vector<std::string> members;

                // Fields
                for (const auto &field : holder->get_fields()) {
                    if (!config_.should_skip_method(name, field)) {
                        members.push_back("InstanceAccessor<&" + wrapper_name + "::GetField_" + field +
                                          ", &" + wrapper_name + "::SetField_" + field + ">(\"" +
                                          field + "\")");
                    }
                }

                // Properties
                for (const auto &prop_name : holder->get_properties()) {
                    if (!config_.should_skip_method(name, prop_name)) {
                        auto prop_info = holder->get_property_info(prop_name);
                        if (prop_info.is_readonly) {
                            members.push_back("InstanceAccessor<&" + wrapper_name + "::GetProp_" +
                                              prop_name + ">(\"" + prop_name + "\")");
                        } else {
                            members.push_back("InstanceAccessor<&" + wrapper_name + "::GetProp_" +
                                              prop_name + ", &" + wrapper_name + "::SetProp_" +
                                              prop_name + ">(\"" + prop_name + "\")");
                        }
                    }
                }

                // Methods
                auto                  fields     = holder->get_fields();
                auto                  properties = holder->get_properties();
                std::set<std::string> field_set(fields.begin(), fields.end());
                std::set<std::string> prop_set(properties.begin(), properties.end());

                for (const auto &m : holder->get_methods()) {
                    if (field_set.find(m) != field_set.end())
                        continue;
                    if (prop_set.find(m) != prop_set.end())
                        continue;
                    if (!config_.should_skip_method(name, m) && !is_python_dunder_method(m)) {
                        members.push_back("InstanceMethod<&" + wrapper_name + "::" + m + ">(\"" + m +
                                          "\")");
                    }
                }

                for (size_t i = 0; i < members.size(); ++i) {
                    std::string comma = (i < members.size() - 1) ? "," : "";
                    line(members[i] + comma);
                }
            });

            line("});");
            blank();
            line("constructor = Napi::Persistent(func);");
            line("constructor.SuppressDestruct();");
            line("exports.Set(\"" + js_class_name + "\", func);");
            line("return exports;");
        });
        line("}");
        blank();
    }

    void write_constructor(const std::string &wrapper_name, const std::string &cpp_type,
                           const rosetta::core::Registry::MetadataHolder *holder) {
        line(wrapper_name + "(const Napi::CallbackInfo& info)");
        line("    : Napi::ObjectWrap<" + wrapper_name + ">(info) {");

        with_indent([&]() {
            line("Napi::Env env = info.Env();");
            line("(void)env;");

            auto ctors = holder->get_constructors();
            if (ctors.empty()) {
                line("// No constructors registered - class may be abstract or created via factory");
            } else {
                line("size_t argc = info.Length();");
                blank();

                bool first = true;
                for (const auto &ctor : ctors) {
                    // Handle lambda constructors
                    if (ctor.is_lambda && !ctor.lambda_body.empty()) {
                        std::string condition = first ? "if" : "} else if";
                        first                 = false;
                        line(condition + " (argc == " +
                             std::to_string(ctor.get_param_types().size()) + ") {");
                        with_indent([&]() {
                            line("instance_ = std::shared_ptr<" + cpp_type + ">(" +
                                 ctor.lambda_body + ");");
                        });
                        continue;
                    }

                    auto        params    = ctor.get_param_types();
                    std::string condition = first ? "if" : "} else if";
                    first                 = false;

                    line(condition + " (argc == " + std::to_string(params.size()) + ") {");
                    with_indent([&]() {
                        if (params.empty()) {
                            line("instance_ = std::make_shared<" + cpp_type + ">();");
                        } else {
                            std::vector<std::string> args;
                            for (size_t i = 0; i < params.size(); ++i) {
                                args.push_back(generate_arg_extraction(params[i], i));
                            }
                            line("instance_ = std::make_shared<" + cpp_type + ">(" +
                                 join(args, ", ") + ");");
                        }
                    });
                }
                line("} else {");
                with_indent([&]() {
                    line("Napi::TypeError::New(env, \"Invalid number of "
                         "arguments\").ThrowAsJavaScriptException();");
                });
                line("}");
            }
        });
        line("}");
        blank();
    }

    void write_field_accessors(const std::string &cpp_type, const std::string &field_name,
                               const rosetta::core::Registry::MetadataHolder *holder) {
        std::type_index field_type = holder->get_field_type(field_name);
        std::string     type_str   = rosetta::demangle(field_type.name());

        // Getter
        line("Napi::Value GetField_" + field_name + "(const Napi::CallbackInfo& info) {");
        with_indent([&]() {
            line("Napi::Env env = info.Env();");
            line("return " + generate_return_conversion(type_str, "instance_->" + field_name) + ";");
        });
        line("}");
        blank();

        // Setter
        line("void SetField_" + field_name +
             "(const Napi::CallbackInfo& info, const Napi::Value& value) {");
        with_indent([&]() {
            line("Napi::Env env = info.Env();");
            line("(void)env;");
            line("instance_->" + field_name + " = " + generate_value_extraction(type_str, "value") +
                 ";");
        });
        line("}");
        blank();
    }

    void write_property_accessors(const std::string &cpp_type, const PropertyMeta &prop,
                                  const rosetta::core::Registry::MetadataHolder *holder) {
        std::string type_str = prop.get_value_type_str();
        std::string cap_name = capitalize(prop.name);

        // Getter
        line("Napi::Value GetProp_" + prop.name + "(const Napi::CallbackInfo& info) {");
        with_indent([&]() {
            line("Napi::Env env = info.Env();");
            line("return " +
                 generate_return_conversion(type_str, "instance_->get" + cap_name + "()") + ";");
        });
        line("}");
        blank();

        // Setter (only if not read-only)
        if (!prop.is_readonly) {
            line("void SetProp_" + prop.name +
                 "(const Napi::CallbackInfo& info, const Napi::Value& value) {");
            with_indent([&]() {
                line("Napi::Env env = info.Env();");
                line("(void)env;");
                line("instance_->set" + cap_name + "(" +
                     generate_value_extraction(type_str, "value") + ");");
            });
            line("}");
            blank();
        }
    }

    void write_method_wrapper(const std::string &cpp_type, const std::string &method_name,
                              const rosetta::core::Registry::MetadataHolder *holder) {
        auto info        = holder->get_method_info(method_name);
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        line("Napi::Value " + method_name + "(const Napi::CallbackInfo& info) {");
        with_indent([&]() {
            line("Napi::Env env = info.Env();");
            blank();

            if (!param_types.empty()) {
                line("if (info.Length() < " + std::to_string(param_types.size()) + ") {");
                with_indent([&]() {
                    line("Napi::TypeError::New(env, \"Wrong number of "
                         "arguments\").ThrowAsJavaScriptException();");
                    line("return env.Undefined();");
                });
                line("}");
                blank();
            }

            // Use Rosetta's invoke_method mechanism
            line("std::vector<rosetta::Any> args;");
            if (!param_types.empty()) {
                line("args.reserve(" + std::to_string(param_types.size()) + ");");
            }

            for (size_t i = 0; i < param_types.size(); ++i) {
                std::string extraction = generate_arg_extraction(param_types[i], i);
                line("args.emplace_back(" + extraction + ");");
            }
            blank();

            line("auto& meta = rosetta::Registry::instance().get<" + cpp_type + ">();");

            if (return_type == "void") {
                line("meta.invoke_method(*instance_, \"" + method_name + "\", std::move(args));");
                line("return env.Undefined();");
            } else {
                line("auto result = meta.invoke_method(*instance_, \"" + method_name +
                     "\", std::move(args));");
                std::string norm_type = normalize_type(return_type);
                line("return " +
                     generate_return_conversion(return_type, "result.as<" + norm_type + ">()") +
                     ";");
            }
        });
        line("}");
        blank();
    }

    void write_conversion_implementations() {
        emit(R"(
// ============================================================================
// Static Member Definitions for Wrapper Classes
// ============================================================================
)");

        auto &registry    = rosetta::Registry::instance();
        auto  class_names = registry.list_classes();

        for (const auto &name : class_names) {
            if (config_.should_skip_class(name))
                continue;
            std::string simple_name  = get_simple_class_name(name);
            std::string wrapper_name = simple_name + "Wrapper";
            line("Napi::FunctionReference " + wrapper_name + "::constructor;");
        }
        blank();

        emit(R"(
// ============================================================================
// Type-Specific Conversion Function Implementations
// ============================================================================
)");

        for (const auto &name : class_names) {
            if (config_.should_skip_class(name))
                continue;
            auto *holder = registry.get_by_name(name);
            if (!holder)
                continue;

            std::string cpp_type     = holder->get_cpp_type_name();
            std::string simple_name  = get_simple_class_name(name);
            std::string wrapper_name = simple_name + "Wrapper";
            std::string safe_name    = make_safe_identifier(name);

            bool should_skip_vector =
                skip_vector_conversion_.find(name) != skip_vector_conversion_.end();

            if (!should_skip_vector) {
                write_vector_conversion_funcs(name, cpp_type, wrapper_name, safe_name);
            }

            write_object_ptr_funcs(name, cpp_type, wrapper_name, safe_name);
        }
    }

    void write_vector_conversion_funcs(const std::string &name, const std::string &cpp_type,
                                       const std::string &wrapper_name,
                                       const std::string &safe_name) {
        // jsArrayToVector_ClassName
        emit(R"(
std::vector<${CPP_TYPE}> jsArrayToVector_${SAFE_NAME}(Napi::Env env, const Napi::Value& val) {
    if (!val.IsArray()) {
        throw std::runtime_error("Expected an array for std::vector<${NAME}>");
    }
    Napi::Array arr = val.As<Napi::Array>();
    std::vector<${CPP_TYPE}> result;
    result.reserve(arr.Length());
    for (uint32_t i = 0; i < arr.Length(); ++i) {
        Napi::Value elem = arr.Get(i);
        if (elem.IsObject()) {
            ${WRAPPER_NAME}* wrapper = Napi::ObjectWrap<${WRAPPER_NAME}>::Unwrap(elem.As<Napi::Object>());
            if (wrapper && wrapper->GetInstance()) {
                result.push_back(*(wrapper->GetInstance()));
            }
        }
    }
    return result;
}
)",
             {{"CPP_TYPE", cpp_type},
              {"SAFE_NAME", safe_name},
              {"NAME", name},
              {"WRAPPER_NAME", wrapper_name}});

        // vectorToJsArray_ClassName
        emit(R"(
Napi::Array vectorToJsArray_${SAFE_NAME}(Napi::Env env, const std::vector<${CPP_TYPE}>& vec) {
    Napi::Array arr = Napi::Array::New(env, vec.size());
    for (size_t i = 0; i < vec.size(); ++i) {
        Napi::Object obj = ${WRAPPER_NAME}::constructor.New({});
        ${WRAPPER_NAME}* wrapper = Napi::ObjectWrap<${WRAPPER_NAME}>::Unwrap(obj);
        if (wrapper && wrapper->GetInstance()) {
            *(wrapper->GetInstance()) = vec[i];
        }
        arr.Set(i, obj);
    }
    return arr;
}
)",
             {{"CPP_TYPE", cpp_type}, {"SAFE_NAME", safe_name}, {"WRAPPER_NAME", wrapper_name}});
    }

    void write_object_ptr_funcs(const std::string &name, const std::string &cpp_type,
                                const std::string &wrapper_name, const std::string &safe_name) {
        // unwrapObjectPtr_ClassName
        emit(R"(
std::shared_ptr<${CPP_TYPE}> unwrapObjectPtr_${SAFE_NAME}(const Napi::Value& val) {
    if (!val.IsObject()) {
        throw std::runtime_error("Expected object for ${NAME}");
    }
    ${WRAPPER_NAME}* wrapper = Napi::ObjectWrap<${WRAPPER_NAME}>::Unwrap(val.As<Napi::Object>());
    if (!wrapper || !wrapper->GetInstance()) {
        throw std::runtime_error("Invalid ${NAME} object");
    }
    return wrapper->GetInstance();
}
)",
             {{"CPP_TYPE", cpp_type},
              {"SAFE_NAME", safe_name},
              {"NAME", name},
              {"WRAPPER_NAME", wrapper_name}});

        // wrapObjectPtr_ClassName
        emit(R"(
Napi::Value wrapObjectPtr_${SAFE_NAME}(Napi::Env env, std::shared_ptr<${CPP_TYPE}> val) {
    if (!val) {
        return env.Null();
    }
    Napi::Object obj = ${WRAPPER_NAME}::constructor.New({});
    ${WRAPPER_NAME}* wrapper = Napi::ObjectWrap<${WRAPPER_NAME}>::Unwrap(obj);
    if (wrapper) {
        wrapper->SetInstance(val);
    }
    return obj;
}
)",
             {{"CPP_TYPE", cpp_type}, {"SAFE_NAME", safe_name}, {"WRAPPER_NAME", wrapper_name}});
    }

    // ========================================================================
    // Free Functions Support - PROPERLY HANDLES OVERLOADS
    // ========================================================================

    void write_free_functions() {
        auto &func_registry  = rosetta::core::FunctionRegistry::instance();
        auto  function_names = func_registry.list_functions();

        if (function_names.empty())
            return;

        emit(R"(
// ============================================================================
// Free Function Wrappers
// ============================================================================
)");

        for (const auto &func_name : function_names) {
            if (config_.should_skip_method("", func_name))
                continue;

            const auto &func_meta = func_registry.get(func_name);

            std::vector<std::string> param_types;
            for (const auto &ti : func_meta.param_types()) {
                param_types.push_back(rosetta::demangle(ti.name()));
            }
            std::string return_type = rosetta::demangle(func_meta.return_type().name());

            write_free_function_wrapper(func_meta, param_types, return_type);
        }
        blank();
    }

    static std::string extract_simple_name(const std::string &qualified_name) {
        auto pos = qualified_name.rfind("::");
        return (pos != std::string::npos) ? qualified_name.substr(pos + 2) : qualified_name;
    }

    void write_free_function_wrapper(const rosetta::core::FunctionMetadata &func_meta,
                                     const std::vector<std::string>        &param_types,
                                     const std::string                     &return_type) {
        std::string py_name       = extract_simple_name(func_meta.name());
        std::string cpp_name      = func_meta.cpp_name();
        std::string wrapper_name  = "Func_" + make_safe_identifier(py_name);
        std::string fixed_cpp_name = fix_type_for_source(cpp_name);

        line("Napi::Value " + wrapper_name + "(const Napi::CallbackInfo& info) {");
        with_indent([&]() {
            line("Napi::Env env = info.Env();");
            blank();

            if (!param_types.empty()) {
                line("if (info.Length() < " + std::to_string(param_types.size()) + ") {");
                with_indent([&]() {
                    line("Napi::TypeError::New(env, \"Wrong number of "
                         "arguments\").ThrowAsJavaScriptException();");
                    line("return env.Undefined();");
                });
                line("}");
                blank();
            }

            std::vector<std::string> args;
            for (size_t i = 0; i < param_types.size(); ++i) {
                args.push_back(generate_arg_extraction(param_types[i], i));
            }

            std::string norm_return = normalize_type(return_type);
            if (norm_return == "void") {
                line(fixed_cpp_name + "(" + join(args, ", ") + ");");
                line("return env.Undefined();");
            } else {
                line("auto result = " + fixed_cpp_name + "(" + join(args, ", ") + ");");
                line("return " + generate_return_conversion(return_type, "result") + ";");
            }
        });
        line("}");
        blank();
    }

    void write_utility_functions() {
        emit(R"(
// ============================================================================
// Utility Functions
// ============================================================================

Napi::Value ListClasses(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto classes = rosetta::Registry::instance().list_classes();
    auto arr = Napi::Array::New(env, classes.size());
    for (size_t i = 0; i < classes.size(); ++i) {
        arr.Set(i, Napi::String::New(env, classes[i]));
    }
    return arr;
}

Napi::Value ListFunctions(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    auto functions = rosetta::core::FunctionRegistry::instance().list_functions();
    auto arr = Napi::Array::New(env, functions.size());
    for (size_t i = 0; i < functions.size(); ++i) {
        arr.Set(i, Napi::String::New(env, functions[i]));
    }
    return arr;
}

Napi::Value GetClassMethods(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1 || !info[0].IsString()) {
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
        return env.Undefined();
    }
    std::string name = info[0].As<Napi::String>().Utf8Value();
    auto* h = rosetta::Registry::instance().get_by_name(name);
    if (!h) {
        Napi::Error::New(env, "Class not found: " + name).ThrowAsJavaScriptException();
        return env.Undefined();
    }
    auto methods = h->get_methods();
    auto arr = Napi::Array::New(env, methods.size());
    for (size_t i = 0; i < methods.size(); ++i) {
        arr.Set(i, Napi::String::New(env, methods[i]));
    }
    return arr;
}

Napi::Value GetClassFields(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1 || !info[0].IsString()) {
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
        return env.Undefined();
    }
    std::string name = info[0].As<Napi::String>().Utf8Value();
    auto* h = rosetta::Registry::instance().get_by_name(name);
    if (!h) {
        Napi::Error::New(env, "Class not found: " + name).ThrowAsJavaScriptException();
        return env.Undefined();
    }
    auto fields = h->get_fields();
    auto arr = Napi::Array::New(env, fields.size());
    for (size_t i = 0; i < fields.size(); ++i) {
        arr.Set(i, Napi::String::New(env, fields[i]));
    }
    return arr;
}

Napi::Value GetClassProperties(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    if (info.Length() < 1 || !info[0].IsString()) {
        Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
        return env.Undefined();
    }
    std::string name = info[0].As<Napi::String>().Utf8Value();
    auto* h = rosetta::Registry::instance().get_by_name(name);
    if (!h) {
        Napi::Error::New(env, "Class not found: " + name).ThrowAsJavaScriptException();
        return env.Undefined();
    }
    auto properties = h->get_properties();
    auto arr = Napi::Array::New(env, properties.size());
    for (size_t i = 0; i < properties.size(); ++i) {
        arr.Set(i, Napi::String::New(env, properties[i]));
    }
    return arr;
}

Napi::Value Version(const Napi::CallbackInfo& info) {
    return Napi::String::New(info.Env(), rosetta::version());
}
)");
    }

    void write_init_function() {
        emit(R"(
// ============================================================================
// Module Initialization
// ============================================================================
)");

        line("Napi::Object Init(Napi::Env env, Napi::Object exports) {");
        with_indent([&]() {
            if (!config_.registration_function.empty()) {
                line("// Register classes with Rosetta");
                line(config_.get_registration_call() + ";");
                blank();
            }

            auto &registry = rosetta::Registry::instance();
            for (const auto &name : registry.list_classes()) {
                if (!config_.should_skip_class(name)) {
                    std::string simple_name = get_simple_class_name(name);
                    line(simple_name + "Wrapper::Init(env, exports);");
                }
            }
            blank();

            line("// Utility functions");
            line("exports.Set(\"listClasses\", Napi::Function::New(env, ListClasses));");
            line("exports.Set(\"listFunctions\", Napi::Function::New(env, ListFunctions));");
            line("exports.Set(\"getClassMethods\", Napi::Function::New(env, GetClassMethods));");
            line("exports.Set(\"getClassFields\", Napi::Function::New(env, GetClassFields));");
            line("exports.Set(\"getClassProperties\", Napi::Function::New(env, GetClassProperties));");
            line("exports.Set(\"version\", Napi::Function::New(env, Version));");
            blank();

            // Register free functions
            auto &func_registry  = rosetta::core::FunctionRegistry::instance();
            auto  function_names = func_registry.list_functions();

            if (!function_names.empty()) {
                line("// Free functions");
                for (const auto &func_name : function_names) {
                    if (config_.should_skip_method("", func_name))
                        continue;
                    const auto &func_meta   = func_registry.get(func_name);
                    std::string py_name     = extract_simple_name(func_meta.name());
                    std::string wrapper_name = "Func_" + make_safe_identifier(py_name);
                    line("exports.Set(\"" + py_name + "\", Napi::Function::New(env, " +
                         wrapper_name + "));");
                }
                blank();
            }

            line("return exports;");
        });
        line("}");
        blank();

        line("NODE_API_MODULE(" + config_.module_name + ", Init)");
    }

    // ========================================================================
    // Helper methods
    // ========================================================================

    std::string capitalize(const std::string &s) {
        if (s.empty())
            return s;
        std::string result = s;
        result[0]          = std::toupper(result[0]);
        return result;
    }

    std::string get_simple_class_name(const std::string &name) {
        size_t pos = name.rfind("::");
        return (pos != std::string::npos) ? name.substr(pos + 2) : name;
    }

    std::string make_safe_identifier(const std::string &name) {
        std::string result = name;
        size_t      pos;
        while ((pos = result.find("::")) != std::string::npos) {
            result.replace(pos, 2, "_");
        }
        return result;
    }

    std::string fix_type_for_source(const std::string &t) {
        std::string r = t;
        size_t      pos;

        // Fix libc++ internal namespaces (macOS/clang)
        while ((pos = r.find("std::__1::")) != std::string::npos)
            r.replace(pos, 10, "std::");

        // Fix libstdc++ internal namespaces (Linux/GCC)
        while ((pos = r.find("std::__cxx11::")) != std::string::npos)
            r.replace(pos, 14, "std::");

        // Handle std::__fs::filesystem -> std::filesystem
        while ((pos = r.find("std::__fs::filesystem")) != std::string::npos)
            r.replace(pos, 21, "std::filesystem");

        while ((pos = r.find("__fs::filesystem")) != std::string::npos)
            r.replace(pos, 16, "std::filesystem");

        // Fix basic_string variants
        while ((pos = r.find(
                    "std::basic_string<char, std::char_traits<char>, std::allocator<char>>")) !=
               std::string::npos)
            r.replace(pos, 69, "std::string");

        while ((pos = r.find("std::basic_string<char, std::char_traits<char>>")) != std::string::npos)
            r.replace(pos, 47, "std::string");

        while ((pos = r.find("std::basic_string<char>")) != std::string::npos)
            r.replace(pos, 23, "std::string");

        while ((pos = r.find("basic_string<char>")) != std::string::npos)
            r.replace(pos, 18, "std::string");

        // Remove allocator from containers
        size_t alloc_start;
        while ((alloc_start = r.find(", std::allocator<")) != std::string::npos) {
            size_t depth = 1, alloc_end = alloc_start + 17;
            while (alloc_end < r.size() && depth > 0) {
                if (r[alloc_end] == '<')
                    depth++;
                else if (r[alloc_end] == '>')
                    depth--;
                alloc_end++;
            }
            r.erase(alloc_start, alloc_end - alloc_start);
        }

        return r;
    }

    std::string normalize_type(const std::string &t) {
        std::string r = fix_type_for_source(t);
        size_t      pos;

        // Remove const
        while ((pos = r.find("const ")) != std::string::npos)
            r.erase(pos, 6);
        while ((pos = r.find(" const")) != std::string::npos)
            r.erase(pos, 6);

        // Remove references but NOT pointers
        while ((pos = r.find("&&")) != std::string::npos)
            r.erase(pos, 2);
        while ((pos = r.find("&")) != std::string::npos)
            r.erase(pos, 1);

        // Trim whitespace
        while (!r.empty() && r[0] == ' ')
            r.erase(0, 1);
        while (!r.empty() && r.back() == ' ')
            r.pop_back();

        return r;
    }

    bool is_pointer_type(const std::string &type) {
        std::string norm = normalize_type(type);
        return !norm.empty() && norm.back() == '*';
    }

    std::string get_pointee_type(const std::string &type) {
        std::string norm = normalize_type(type);
        if (!norm.empty() && norm.back() == '*') {
            norm.pop_back();
            while (!norm.empty() && norm.back() == ' ')
                norm.pop_back();
        }
        return norm;
    }

    bool is_vector_type(const std::string &type) {
        std::string norm = normalize_type(type);
        return norm.find("vector<") != std::string::npos ||
               norm.find("std::vector<") != std::string::npos;
    }

    std::string extract_vector_element_type(const std::string &type) {
        std::string norm = normalize_type(type);

        size_t start = norm.find("vector<");
        if (start == std::string::npos)
            return "";
        start += 7;

        int    depth = 1;
        size_t end   = start;
        while (end < norm.size() && depth > 0) {
            if (norm[end] == '<')
                depth++;
            else if (norm[end] == '>')
                depth--;
            if (depth > 0)
                end++;
        }

        std::string elem = norm.substr(start, end - start);
        while (!elem.empty() && elem[0] == ' ')
            elem.erase(0, 1);
        while (!elem.empty() && elem.back() == ' ')
            elem.pop_back();

        return elem;
    }

    bool is_registered_class(const std::string &type_name) {
        auto       &registry = rosetta::Registry::instance();
        std::string norm     = normalize_type(type_name);

        if (!norm.empty() && norm.back() == '*') {
            norm.pop_back();
            while (!norm.empty() && norm.back() == ' ')
                norm.pop_back();
        }

        if (registry.get_by_name(norm) != nullptr)
            return true;

        size_t pos = norm.rfind("::");
        if (pos != std::string::npos) {
            std::string short_name = norm.substr(pos + 2);
            if (registry.get_by_name(short_name) != nullptr)
                return true;
        }
        return false;
    }

    std::string get_registered_name(const std::string &type_name) {
        auto       &registry = rosetta::Registry::instance();
        std::string norm     = normalize_type(type_name);

        if (!norm.empty() && norm.back() == '*') {
            norm.pop_back();
            while (!norm.empty() && norm.back() == ' ')
                norm.pop_back();
        }

        if (registry.get_by_name(norm) != nullptr)
            return norm;

        size_t pos = norm.rfind("::");
        if (pos != std::string::npos) {
            std::string short_name = norm.substr(pos + 2);
            if (registry.get_by_name(short_name) != nullptr)
                return short_name;
        }
        return norm;
    }

    bool needs_typed_array_conversion(const std::string &t) {
        std::string norm = normalize_type(t);
        return norm.find("vector<double>") != std::string::npos ||
               norm.find("vector<int>") != std::string::npos ||
               norm.find("vector<float>") != std::string::npos;
    }

    bool is_function_type(const std::string &type) {
        std::string norm = normalize_type(type);
        return norm.find("function<") != std::string::npos ||
               norm.find("std::function<") != std::string::npos;
    }

    struct FunctionSignature {
        std::string              return_type;
        std::vector<std::string> param_types;
    };

    FunctionSignature extract_function_signature(const std::string &type) {
        FunctionSignature sig;
        std::string       norm = normalize_type(type);

        size_t start = norm.find("function<");
        if (start == std::string::npos)
            return sig;
        start += 9;

        size_t paren_start = norm.find('(', start);
        if (paren_start == std::string::npos)
            return sig;

        sig.return_type = norm.substr(start, paren_start - start);
        while (!sig.return_type.empty() && sig.return_type[0] == ' ')
            sig.return_type.erase(0, 1);
        while (!sig.return_type.empty() && sig.return_type.back() == ' ')
            sig.return_type.pop_back();

        size_t paren_end = norm.find(')', paren_start);
        if (paren_end == std::string::npos)
            return sig;

        std::string params_str = norm.substr(paren_start + 1, paren_end - paren_start - 1);

        if (!params_str.empty()) {
            int    depth      = 0;
            size_t last_start = 0;
            for (size_t i = 0; i <= params_str.size(); ++i) {
                if (i == params_str.size() || (params_str[i] == ',' && depth == 0)) {
                    std::string param = params_str.substr(last_start, i - last_start);
                    param             = normalize_type(param);
                    if (!param.empty()) {
                        sig.param_types.push_back(param);
                    }
                    last_start = i + 1;
                } else if (params_str[i] == '<') {
                    depth++;
                } else if (params_str[i] == '>') {
                    depth--;
                }
            }
        }

        return sig;
    }

    std::string generate_function_arg_extraction(const std::string &type, size_t index) {
        std::string idx = std::to_string(index);
        auto        sig = extract_function_signature(type);

        if (sig.return_type.empty()) {
            return "info[" + idx + "]";
        }

        std::ostringstream oss;
        oss << "[fn = std::make_shared<Napi::FunctionReference>(Napi::Persistent(info[" << idx
            << "].As<Napi::Function>())), env = info.Env()](";

        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << "const " << sig.param_types[i] << "& p" << i;
        }
        oss << ") -> " << sig.return_type << " {\n";

        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            std::string param_type = sig.param_types[i];
            if (is_registered_class(param_type)) {
                std::string reg_name  = get_registered_name(param_type);
                std::string safe_name = make_safe_identifier(reg_name);
                oss << "                Napi::Value arg" << i << " = wrapObjectPtr_" << safe_name
                    << "(env, std::make_shared<" << param_type << ">(p" << i << "));\n";
            } else if (param_type == "double" || param_type == "float") {
                oss << "                Napi::Value arg" << i << " = Napi::Number::New(env, p" << i
                    << ");\n";
            } else if (param_type == "int" || param_type == "long" || param_type == "size_t") {
                oss << "                Napi::Value arg" << i << " = Napi::Number::New(env, p" << i
                    << ");\n";
            } else if (param_type == "bool") {
                oss << "                Napi::Value arg" << i << " = Napi::Boolean::New(env, p" << i
                    << ");\n";
            } else if (param_type.find("string") != std::string::npos) {
                oss << "                Napi::Value arg" << i << " = Napi::String::New(env, p" << i
                    << ");\n";
            } else {
                oss << "                Napi::Value arg" << i
                    << " = Napi::Number::New(env, static_cast<double>(p" << i << "));\n";
            }
        }

        oss << "                Napi::Value result = fn->Call({";
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << "arg" << i;
        }
        oss << "});\n";

        if (is_registered_class(sig.return_type)) {
            std::string reg_name  = get_registered_name(sig.return_type);
            std::string safe_name = make_safe_identifier(reg_name);
            oss << "                return *unwrapObjectPtr_" << safe_name << "(result);\n";
        } else if (sig.return_type == "double" || sig.return_type == "float") {
            oss << "                return result.As<Napi::Number>().DoubleValue();\n";
        } else if (sig.return_type == "int" || sig.return_type == "long" ||
                   sig.return_type == "size_t") {
            oss << "                return result.As<Napi::Number>().Int32Value();\n";
        } else if (sig.return_type == "bool") {
            oss << "                return result.As<Napi::Boolean>().Value();\n";
        } else if (sig.return_type.find("string") != std::string::npos) {
            oss << "                return result.As<Napi::String>().Utf8Value();\n";
        } else {
            oss << "                return static_cast<" << sig.return_type
                << ">(result.As<Napi::Number>().DoubleValue());\n";
        }

        oss << "            }";
        return oss.str();
    }

    std::string generate_arg_extraction(const std::string &type, size_t index) {
        std::string idx  = std::to_string(index);
        std::string norm = normalize_type(type);

        // Handle std::function types
        if (is_function_type(norm)) {
            return generate_function_arg_extraction(type, index);
        }

        // Handle pointer parameters
        if (is_pointer_type(norm)) {
            std::string pointee = get_pointee_type(norm);
            if (is_registered_class(pointee)) {
                std::string reg_name  = get_registered_name(pointee);
                std::string safe_name = make_safe_identifier(reg_name);
                return "unwrapObjectPtr_" + safe_name + "(info[" + idx + "]).get()";
            }
        }

        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "typedArrayToVectorDouble(info[" + idx + "].As<Napi::Float64Array>())";
            }
            if (elem == "int") {
                return "typedArrayToVectorInt(info[" + idx + "].As<Napi::Int32Array>())";
            }
            if (is_registered_class(elem)) {
                std::string reg_name  = get_registered_name(elem);
                std::string safe_name = make_safe_identifier(reg_name);
                if (skip_vector_conversion_.find(reg_name) == skip_vector_conversion_.end()) {
                    return "jsArrayToVector_" + safe_name + "(info.Env(), info[" + idx + "])";
                }
            }
        }

        if (norm.find("string") != std::string::npos) {
            return "info[" + idx + "].As<Napi::String>().Utf8Value()";
        }
        if (norm == "bool") {
            return "info[" + idx + "].As<Napi::Boolean>().Value()";
        }
        if (norm == "int" || norm == "long" || norm == "size_t") {
            return "info[" + idx + "].As<Napi::Number>().Int32Value()";
        }
        if (norm == "float" || norm == "double") {
            return "info[" + idx + "].As<Napi::Number>().DoubleValue()";
        }

        // For registered class types passed by value
        if (is_registered_class(norm)) {
            std::string reg_name  = get_registered_name(norm);
            std::string safe_name = make_safe_identifier(reg_name);
            return "*unwrapObjectPtr_" + safe_name + "(info[" + idx + "])";
        }

        return "info[" + idx + "].As<Napi::Number>().DoubleValue()";
    }

    std::string generate_value_extraction(const std::string &type, const std::string &var) {
        std::string norm = normalize_type(type);

        if (is_pointer_type(norm)) {
            std::string pointee = get_pointee_type(norm);
            if (is_registered_class(pointee)) {
                std::string reg_name  = get_registered_name(pointee);
                std::string safe_name = make_safe_identifier(reg_name);
                return "unwrapObjectPtr_" + safe_name + "(" + var + ").get()";
            }
        }

        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "typedArrayToVectorDouble(" + var + ".As<Napi::Float64Array>())";
            }
            if (elem == "int") {
                return "typedArrayToVectorInt(" + var + ".As<Napi::Int32Array>())";
            }
            if (is_registered_class(elem)) {
                std::string reg_name  = get_registered_name(elem);
                std::string safe_name = make_safe_identifier(reg_name);
                if (skip_vector_conversion_.find(reg_name) == skip_vector_conversion_.end()) {
                    return "jsArrayToVector_" + safe_name + "(env, " + var + ")";
                }
            }
        }

        if (norm.find("string") != std::string::npos) {
            return var + ".As<Napi::String>().Utf8Value()";
        }
        if (norm == "bool") {
            return var + ".As<Napi::Boolean>().Value()";
        }
        if (norm == "int" || norm == "long" || norm == "size_t") {
            return var + ".As<Napi::Number>().Int32Value()";
        }
        if (norm == "float" || norm == "double") {
            return var + ".As<Napi::Number>().DoubleValue()";
        }

        if (is_registered_class(norm)) {
            std::string reg_name  = get_registered_name(norm);
            std::string safe_name = make_safe_identifier(reg_name);
            return "*unwrapObjectPtr_" + safe_name + "(" + var + ")";
        }

        return var + ".As<Napi::Number>().DoubleValue()";
    }

    std::string generate_return_conversion(const std::string &type, const std::string &var) {
        std::string norm = normalize_type(type);

        if (is_pointer_type(norm)) {
            std::string pointee = get_pointee_type(norm);
            if (is_registered_class(pointee)) {
                std::string reg_name  = get_registered_name(pointee);
                std::string safe_name = make_safe_identifier(reg_name);
                return "wrapObjectPtr_" + safe_name + "(env, std::shared_ptr<" + pointee + ">(" +
                       var + ", [](auto*){}))";
            }
        }

        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "vectorToTypedArray(env, " + var + ")";
            }
            if (elem == "int") {
                return "vectorIntToTypedArray(env, " + var + ")";
            }
            if (is_registered_class(elem)) {
                std::string reg_name  = get_registered_name(elem);
                std::string safe_name = make_safe_identifier(reg_name);
                if (skip_vector_conversion_.find(reg_name) == skip_vector_conversion_.end()) {
                    return "vectorToJsArray_" + safe_name + "(env, " + var + ")";
                }
            }
        }

        if (norm.find("string") != std::string::npos) {
            return "Napi::String::New(env, " + var + ")";
        }
        if (norm == "bool") {
            return "Napi::Boolean::New(env, " + var + ")";
        }
        if (norm == "int" || norm == "long" || norm == "size_t" || norm == "float" ||
            norm == "double") {
            return "Napi::Number::New(env, " + var + ")";
        }
        if (norm == "void") {
            return "env.Undefined()";
        }

        if (is_registered_class(norm)) {
            std::string reg_name  = get_registered_name(norm);
            std::string safe_name = make_safe_identifier(reg_name);
            return "wrapObjectPtr_" + safe_name + "(env, std::make_shared<" + norm + ">(" + var +
                   "))";
        }

        return "Napi::Number::New(env, " + var + ")";
    }
};
