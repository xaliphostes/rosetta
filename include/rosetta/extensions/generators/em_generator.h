// ============================================================================
// Emscripten binding generator using Rosetta introspection
// Version 3: Clean JavaScript API with automatic binding
// ============================================================================
#pragma once

#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <rosetta/rosetta.h>
#include <string>
#include <typeindex>
#include <vector>
#include <sstream>
#include <map>
#include <functional>
#include <unordered_map>

namespace em = emscripten;

namespace rosetta::em_gen {

    // ============================================================================
    // Type Cast Registry - For converting Any back to em::val
    // ============================================================================

    class TypeCastRegistry {
    public:
        using CastFunc = std::function<em::val(const core::Any&)>;

        static TypeCastRegistry& instance() {
            static TypeCastRegistry reg;
            return reg;
        }

        template <typename T>
        void register_cast() {
            casts_[std::type_index(typeid(T))] = [](const core::Any& value) -> em::val {
                return em::val(value.as<T>());
            };
        }

        em::val cast(const core::Any& value) const {
            auto it = casts_.find(value.get_type_index());
            if (it != casts_.end()) {
                return it->second(value);
            }
            return em::val::undefined();
        }

        bool has_cast(std::type_index type) const {
            return casts_.find(type) != casts_.end();
        }

    private:
        std::unordered_map<std::type_index, CastFunc> casts_;
    };

    // ============================================================================
    // TypeScript Declaration Generator
    // ============================================================================

    class TypeScriptGenerator {
    public:
        static TypeScriptGenerator& instance() {
            static TypeScriptGenerator gen;
            return gen;
        }

        void add_class(const std::string& name, 
                      const std::vector<std::string>& fields,
                      const std::vector<std::string>& methods,
                      const std::string& base_class = "") {
            ClassInfo info;
            info.name = name;
            info.fields = fields;
            info.methods = methods;
            info.base_class = base_class;
            classes_[name] = info;
        }

        void add_constructor(const std::string& class_name, 
                            const std::vector<std::type_index>& arg_types) {
            constructor_types_[class_name].push_back(arg_types);
        }

        void add_field_type(const std::string& class_name, const std::string& field_name, 
                           std::type_index type) {
            field_types_.insert_or_assign(class_name + "." + field_name, type);
        }

        void add_method_info(const std::string& class_name, const std::string& method_name,
                            std::type_index return_type, const std::vector<std::type_index>& arg_types) {
            MethodInfo info;
            info.return_type = return_type;
            info.arg_types = arg_types;
            method_types_[class_name + "." + method_name] = info;
        }

        void add_function(const std::string& name, std::type_index return_type,
                         const std::vector<std::type_index>& arg_types) {
            MethodInfo info;
            info.return_type = return_type;
            info.arg_types = arg_types;
            functions_[name] = info;
        }

        void set_type_name(std::type_index type, const std::string& name) {
            type_names_[type] = name;
        }

        std::string generate() const {
            std::ostringstream ts;
            
            ts << "// Auto-generated TypeScript declarations for Rosetta Emscripten bindings\n";
            ts << "// Generated by em_generator_v3\n\n";
            
            ts << "declare module 'Module' {\n";
            ts << "  export interface EmscriptenModule {\n";
            
            // Classes
            for (const auto& [name, info] : classes_) {
                ts << "    " << name << ": " << name << "Constructor;\n";
            }
            
            // Free functions
            for (const auto& [name, info] : functions_) {
                ts << "    " << name << "(";
                for (size_t i = 0; i < info.arg_types.size(); ++i) {
                    if (i > 0) ts << ", ";
                    ts << "arg" << i << ": " << type_to_ts(info.arg_types[i]);
                }
                ts << "): " << type_to_ts(info.return_type) << ";\n";
            }
            
            // Utility functions
            ts << "    listClasses(): string[];\n";
            ts << "    version(): string;\n";
            ts << "    generateTypeScript(): string;\n";
            
            ts << "  }\n\n";
            
            // Class interfaces
            for (const auto& [name, info] : classes_) {
                // Constructor interface
                ts << "  interface " << name << "Constructor {\n";
                
                // Generate constructor signatures
                auto ctor_it = constructor_types_.find(name);
                if (ctor_it != constructor_types_.end() && !ctor_it->second.empty()) {
                    for (const auto& ctor_args : ctor_it->second) {
                        ts << "    new(";
                        for (size_t i = 0; i < ctor_args.size(); ++i) {
                            if (i > 0) ts << ", ";
                            ts << "arg" << i << ": " << type_to_ts(ctor_args[i]);
                        }
                        ts << "): " << name << ";\n";
                    }
                } else {
                    ts << "    new(): " << name << ";\n";
                }
                
                ts << "    $meta(): { fields: string[], methods: string[] };\n";
                ts << "  }\n\n";
                
                // Instance interface
                ts << "  interface " << name;
                if (!info.base_class.empty()) {
                    ts << " extends " << info.base_class;
                }
                ts << " {\n";
                
                // Fields
                for (const auto& field : info.fields) {
                    std::string key = name + "." + field;
                    auto it = field_types_.find(key);
                    std::string ts_type = "any";
                    if (it != field_types_.end()) {
                        ts_type = type_to_ts(it->second);
                    }
                    ts << "    " << field << ": " << ts_type << ";\n";
                }
                
                // Methods
                for (const auto& method : info.methods) {
                    std::string key = name + "." + method;
                    auto it = method_types_.find(key);
                    if (it != method_types_.end()) {
                        ts << "    " << method << "(";
                        for (size_t i = 0; i < it->second.arg_types.size(); ++i) {
                            if (i > 0) ts << ", ";
                            ts << "arg" << i << ": " << type_to_ts(it->second.arg_types[i]);
                        }
                        ts << "): " << type_to_ts(it->second.return_type) << ";\n";
                    } else {
                        ts << "    " << method << "(...args: any[]): any;\n";
                    }
                }
                
                // Internal methods
                ts << "    $get(field: string): any;\n";
                ts << "    $set(field: string, value: any): void;\n";
                ts << "    $call(method: string, args: any[]): any;\n";
                ts << "    delete(): void;\n";
                
                ts << "  }\n\n";
            }
            
            ts << "  export default function(): Promise<EmscriptenModule>;\n";
            ts << "}\n";
            
            return ts.str();
        }

    private:
        struct ClassInfo {
            std::string name;
            std::vector<std::string> fields;
            std::vector<std::string> methods;
            std::string base_class;
        };

        struct MethodInfo {
            std::type_index return_type = std::type_index(typeid(void));
            std::vector<std::type_index> arg_types;
        };

        std::map<std::string, ClassInfo> classes_;
        std::map<std::string, std::vector<std::vector<std::type_index>>> constructor_types_;
        std::map<std::string, std::type_index> field_types_;
        std::map<std::string, MethodInfo> method_types_;
        std::map<std::string, MethodInfo> functions_;
        std::map<std::type_index, std::string> type_names_;

        std::string type_to_ts(std::type_index type) const {
            // Check custom type names first (includes registered classes)
            auto custom_it = type_names_.find(type);
            if (custom_it != type_names_.end()) {
                return custom_it->second;
            }

            // Primitives
            if (type == std::type_index(typeid(int))) return "number";
            if (type == std::type_index(typeid(double))) return "number";
            if (type == std::type_index(typeid(float))) return "number";
            if (type == std::type_index(typeid(size_t))) return "number";
            if (type == std::type_index(typeid(long))) return "number";
            if (type == std::type_index(typeid(long long))) return "number";
            if (type == std::type_index(typeid(unsigned int))) return "number";
            if (type == std::type_index(typeid(unsigned long))) return "number";
            if (type == std::type_index(typeid(short))) return "number";
            if (type == std::type_index(typeid(char))) return "number";
            if (type == std::type_index(typeid(bool))) return "boolean";
            if (type == std::type_index(typeid(std::string))) return "string";
            if (type == std::type_index(typeid(void))) return "void";
            
            // Vectors
            if (type == std::type_index(typeid(std::vector<double>))) return "number[]";
            if (type == std::type_index(typeid(std::vector<float>))) return "number[]";
            if (type == std::type_index(typeid(std::vector<int>))) return "number[]";
            if (type == std::type_index(typeid(std::vector<size_t>))) return "number[]";
            if (type == std::type_index(typeid(std::vector<std::string>))) return "string[]";
            if (type == std::type_index(typeid(std::vector<bool>))) return "boolean[]";
            
            return "any";
        }
    };

    // ============================================================================
    // Type Converters
    // ============================================================================

    inline em::val any_to_val(const core::Any &value) {
        if (!value.has_value()) return em::val::undefined();

        auto type = value.get_type_index();

        // Primitives
        if (type == std::type_index(typeid(int))) return em::val(value.as<int>());
        if (type == std::type_index(typeid(double))) return em::val(value.as<double>());
        if (type == std::type_index(typeid(float))) return em::val(value.as<float>());
        if (type == std::type_index(typeid(bool))) return em::val(value.as<bool>());
        if (type == std::type_index(typeid(std::string))) return em::val(value.as<std::string>());
        if (type == std::type_index(typeid(size_t))) return em::val(static_cast<unsigned long>(value.as<size_t>()));
        if (type == std::type_index(typeid(long))) return em::val(value.as<long>());
        if (type == std::type_index(typeid(void))) return em::val::undefined();

        // Vectors
        if (type == std::type_index(typeid(std::vector<double>))) {
            const auto &vec = value.as<std::vector<double>>();
            em::val arr = em::val::array();
            for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);
            return arr;
        }
        if (type == std::type_index(typeid(std::vector<int>))) {
            const auto &vec = value.as<std::vector<int>>();
            em::val arr = em::val::array();
            for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);
            return arr;
        }
        if (type == std::type_index(typeid(std::vector<std::string>))) {
            const auto &vec = value.as<std::vector<std::string>>();
            em::val arr = em::val::array();
            for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);
            return arr;
        }

        // Check registered type casts
        if (TypeCastRegistry::instance().has_cast(type)) {
            return TypeCastRegistry::instance().cast(value);
        }

        return em::val::undefined();
    }

    inline core::Any val_to_any(const em::val &js_val, std::type_index expected_type) {
        if (expected_type == std::type_index(typeid(int))) return core::Any(js_val.as<int>());
        if (expected_type == std::type_index(typeid(double))) return core::Any(js_val.as<double>());
        if (expected_type == std::type_index(typeid(float))) return core::Any(js_val.as<float>());
        if (expected_type == std::type_index(typeid(bool))) return core::Any(js_val.as<bool>());
        if (expected_type == std::type_index(typeid(std::string))) return core::Any(js_val.as<std::string>());
        if (expected_type == std::type_index(typeid(size_t))) return core::Any(static_cast<size_t>(js_val.as<unsigned long>()));

        // Vectors
        if (expected_type == std::type_index(typeid(std::vector<double>))) {
            std::vector<double> vec;
            unsigned length = js_val["length"].as<unsigned>();
            for (unsigned i = 0; i < length; ++i) vec.push_back(js_val[i].as<double>());
            return core::Any(vec);
        }
        if (expected_type == std::type_index(typeid(std::vector<int>))) {
            std::vector<int> vec;
            unsigned length = js_val["length"].as<unsigned>();
            for (unsigned i = 0; i < length; ++i) vec.push_back(js_val[i].as<int>());
            return core::Any(vec);
        }

        throw std::runtime_error("Unsupported type for JavaScript conversion");
    }

    // ============================================================================
    // Constructor Binder
    // ============================================================================

    template <typename T, typename TupleType>
    struct ConstructorBinder;

    template <typename T, typename... Args>
    struct ConstructorBinder<T, std::tuple<Args...>> {
        template <typename ClassType>
        static void bind(ClassType &em_class) {
            em_class.template constructor<Args...>();
        }
        
        static void register_typescript(const std::string& class_name) {
            std::vector<std::type_index> arg_types = {std::type_index(typeid(Args))...};
            TypeScriptGenerator::instance().add_constructor(class_name, arg_types);
        }
    };

    // ============================================================================
    // Class Wrapper - Provides generic access via _get/_set/_call
    // ============================================================================

    template <typename T>
    struct ClassWrapper {
        // Field getter
        static em::val getField(T& obj, const std::string& name) {
            const auto &meta = core::Registry::instance().get<T>();
            try {
                core::Any value = meta.get_field(obj, name);
                return any_to_val(value);
            } catch (const std::exception& e) {
                throw std::runtime_error("Field '" + name + "' not found: " + e.what());
            }
        }

        // Field setter
        static void setField(T& obj, const std::string& name, em::val value) {
            const auto &meta = core::Registry::instance().get<T>();
            try {
                auto field_type = meta.get_field_type(name);
                core::Any cpp_val = val_to_any(value, field_type);
                meta.set_field(obj, name, cpp_val);
            } catch (const std::exception& e) {
                throw std::runtime_error("Cannot set field '" + name + "': " + e.what());
            }
        }

        // Method caller
        static em::val callMethod(T& obj, const std::string& name, em::val args) {
            const auto &meta = core::Registry::instance().get<T>();
            try {
                size_t arity = meta.get_method_arity(name);
                const auto &arg_types = meta.get_method_arg_types(name);

                std::vector<core::Any> cpp_args;
                for (size_t i = 0; i < arity; ++i) {
                    cpp_args.push_back(val_to_any(args[i], arg_types[i]));
                }

                core::Any result = meta.invoke_method(obj, name, cpp_args);
                return any_to_val(result);
            } catch (const std::exception& e) {
                throw std::runtime_error("Method '" + name + "' call failed: " + e.what());
            }
        }

        // Get class metadata as JSON
        static em::val getMetadata() {
            const auto &meta = core::Registry::instance().get<T>();
            em::val info = em::val::object();

            // Fields
            em::val fields = em::val::array();
            for (const auto& f : meta.fields()) {
                fields.call<void>("push", em::val(f));
            }
            info.set("fields", fields);

            // Methods
            em::val methods = em::val::array();
            for (const auto& m : meta.methods()) {
                methods.call<void>("push", em::val(m));
            }
            info.set("methods", methods);

            return info;
        }
    };

    // ============================================================================
    // Auto Class Binder
    // ============================================================================

    template <typename T, typename Base, typename... CtorSignatures>
    class AutoBinderWithBase {
    public:
        static void bind(const std::string& js_name) {
            const auto &meta = core::Registry::instance().get<T>();
            std::string name = js_name.empty() ? meta.name() : js_name;

            // Register type cast for this class
            TypeCastRegistry::instance().register_cast<T>();
            
            // Register type name for TypeScript
            TypeScriptGenerator::instance().set_type_name(std::type_index(typeid(T)), name);

            // Create class with base class
            auto em_class = em::class_<T, em::base<Base>>(name.c_str());

            // Bind constructors
            if constexpr (!std::is_abstract_v<T>) {
                if constexpr (sizeof...(CtorSignatures) > 0) {
                    (ConstructorBinder<T, CtorSignatures>::bind(em_class), ...);
                    // Register for TypeScript
                    (ConstructorBinder<T, CtorSignatures>::register_typescript(name), ...);
                } else {
                    const auto &ctors = meta.constructor_infos();
                    for (const auto &ctor : ctors) {
                        if (ctor.arity == 0) {
                            em_class.template constructor<>();
                            TypeScriptGenerator::instance().add_constructor(name, {});
                            break;
                        }
                    }
                }
            }

            // Bind generic accessors
            em_class.function("$get", &ClassWrapper<T>::getField);
            em_class.function("$set", &ClassWrapper<T>::setField);
            em_class.function("$call", &ClassWrapper<T>::callMethod);
            em_class.class_function("$meta", &ClassWrapper<T>::getMetadata);

            // Collect TypeScript info
            std::string base_name = core::Registry::instance().get<Base>().name();
            TypeScriptGenerator::instance().add_class(name, meta.fields(), meta.methods(), base_name);
            
            // Add field type info
            for (const auto& field : meta.fields()) {
                auto field_type = meta.get_field_type(field);
                TypeScriptGenerator::instance().add_field_type(name, field, field_type);
            }
            
            // Add method type info
            for (const auto& method : meta.methods()) {
                try {
                    auto return_type = meta.get_method_return_type(method);
                    auto arg_types = meta.get_method_arg_types(method);
                    TypeScriptGenerator::instance().add_method_info(name, method, return_type, arg_types);
                } catch (...) {}
            }
        }
    };

    template <typename T, typename... CtorSignatures>
    class AutoBinder {
    public:
        static void bind(const std::string& js_name) {
            const auto &meta = core::Registry::instance().get<T>();
            std::string name = js_name.empty() ? meta.name() : js_name;

            // Register type cast for this class so methods returning T work
            TypeCastRegistry::instance().register_cast<T>();
            
            // Register type name for TypeScript
            TypeScriptGenerator::instance().set_type_name(std::type_index(typeid(T)), name);

            auto em_class = em::class_<T>(name.c_str());

            // Bind constructors
            if constexpr (!std::is_abstract_v<T>) {
                if constexpr (sizeof...(CtorSignatures) > 0) {
                    (ConstructorBinder<T, CtorSignatures>::bind(em_class), ...);
                    // Register for TypeScript
                    (ConstructorBinder<T, CtorSignatures>::register_typescript(name), ...);
                } else {
                    // Try default constructor
                    const auto &ctors = meta.constructor_infos();
                    for (const auto &ctor : ctors) {
                        if (ctor.arity == 0) {
                            em_class.template constructor<>();
                            TypeScriptGenerator::instance().add_constructor(name, {});
                            break;
                        }
                    }
                }
            }

            // Bind generic accessors
            em_class.function("$get", &ClassWrapper<T>::getField);
            em_class.function("$set", &ClassWrapper<T>::setField);
            em_class.function("$call", &ClassWrapper<T>::callMethod);
            em_class.class_function("$meta", &ClassWrapper<T>::getMetadata);

            // Collect TypeScript info
            TypeScriptGenerator::instance().add_class(name, meta.fields(), meta.methods());
            
            // Add field type info
            for (const auto& field : meta.fields()) {
                auto field_type = meta.get_field_type(field);
                TypeScriptGenerator::instance().add_field_type(name, field, field_type);
            }
            
            // Add method type info
            for (const auto& method : meta.methods()) {
                try {
                    auto return_type = meta.get_method_return_type(method);
                    auto arg_types = meta.get_method_arg_types(method);
                    TypeScriptGenerator::instance().add_method_info(name, method, return_type, arg_types);
                } catch (...) {}
            }
        }
    };

    // ============================================================================
    // Generator
    // ============================================================================

    class EmGenerator {
    public:
        EmGenerator() = default;

        /**
         * @brief Bind a class without base class
         */
        template <typename T, typename... CtorSignatures>
        EmGenerator &bind_class(const std::string &js_name = "") {
            AutoBinder<T, CtorSignatures...>::bind(js_name);
            return *this;
        }

        /**
         * @brief Bind a derived class with base class for inheritance
         * 
         * Usage:
         *   gen.bind_derived_class<Dog, Animal, std::tuple<std::string>>("Dog");
         */
        template <typename Derived, typename Base, typename... CtorSignatures>
        EmGenerator &bind_derived_class(const std::string &js_name = "") {
            AutoBinderWithBase<Derived, Base, CtorSignatures...>::bind(js_name);
            return *this;
        }

        /**
         * @brief Bind a free function
         */
        template <typename Ret, typename... Args>
        EmGenerator &bind_function(const std::string &name, Ret (*func)(Args...)) {
            em::function(name.c_str(), func);
            
            // Collect TypeScript info
            std::vector<std::type_index> arg_types = {std::type_index(typeid(Args))...};
            TypeScriptGenerator::instance().add_function(name, std::type_index(typeid(Ret)), arg_types);
            
            return *this;
        }

        /**
         * @brief Add utility functions
         */
        EmGenerator &add_utilities() {
            struct Utils {
                static em::val listClasses() {
                    auto classes = core::Registry::instance().list_classes();
                    em::val arr = em::val::array();
                    for (size_t i = 0; i < classes.size(); ++i) {
                        arr.set(i, classes[i]);
                    }
                    return arr;
                }
                static std::string version() { return rosetta::version(); }
                static std::string generateTypeScript() {
                    return TypeScriptGenerator::instance().generate();
                }
            };
            em::function("listClasses", &Utils::listClasses);
            em::function("version", &Utils::version);
            em::function("generateTypeScript", &Utils::generateTypeScript);
            return *this;
        }

        /**
         * @brief Get the generated TypeScript declarations
         */
        static std::string get_typescript_declarations() {
            return TypeScriptGenerator::instance().generate();
        }
    };

    inline EmGenerator create_bindings() { return EmGenerator(); }

    // ============================================================================
    // JavaScript Enhancement Code Generator
    // ============================================================================

    /**
     * @brief Generate JavaScript code that enhances classes with proper getters/setters
     * 
     * Call this and execute the returned string in JavaScript after module loads
     */
    inline std::string generateJSEnhancements() {
        std::ostringstream js;
        
        js << R"(
function enhanceRosettaClasses(Module) {
    const classes = Module.listClasses();
    
    classes.forEach(className => {
        const ClassRef = Module[className];
        if (!ClassRef) return;
        
        // Get metadata
        const meta = ClassRef.$meta();
        
        // Add field accessors as properties
        meta.fields.forEach(field => {
            Object.defineProperty(ClassRef.prototype, field, {
                get: function() { return this.$get(field); },
                set: function(v) { this.$set(field, v); },
                enumerable: true
            });
        });
        
        // Add method wrappers
        meta.methods.forEach(method => {
            if (!ClassRef.prototype[method]) {
                ClassRef.prototype[method] = function(...args) {
                    return this.$call(method, args);
                };
            }
        });
    });
    
    return Module;
}
)";
        return js.str();
    }

} // namespace rosetta::em_gen

// ============================================================================
// Macros
// ============================================================================

#define BEGIN_EM_MODULE(module_name) \
    EMSCRIPTEN_BINDINGS(module_name) { \
        auto gen = rosetta::em_gen::create_bindings();

#define BIND_EM_CLASS_AUTO(Class, ...) \
    gen.bind_class<Class, __VA_ARGS__>(#Class);

#define BIND_EM_CLASS(Class) \
    gen.bind_class<Class>(#Class);

/**
 * @brief Bind a derived class with inheritance
 * 
 * Usage:
 *   BIND_EM_DERIVED_CLASS(Dog, Animal, std::tuple<std::string>);
 */
#define BIND_EM_DERIVED_CLASS(Derived, Base, ...) \
    gen.bind_derived_class<Derived, Base, __VA_ARGS__>(#Derived);

#define BIND_EM_FUNCTION(func) gen.bind_function(#func, func);

#define BIND_EM_UTILITIES() gen.add_utilities();

#define END_EM_MODULE() }