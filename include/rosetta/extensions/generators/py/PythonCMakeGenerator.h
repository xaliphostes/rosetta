#pragma once
#include "../common/CodeWriter.h"

// ============================================================================
// Python CMakeLists.txt Generator - Modernized
// ============================================================================

class PythonCMakeGenerator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_project();
        write_python_config();
        write_sources();
        write_pybind11_config();
        write_module();
        write_install();
    }

private:
    void write_header() {
        emit(R"(
            # ============================================================================
            # AUTO-GENERATED CMakeLists.txt - DO NOT EDIT
            # Generated by binding_generator
            # ============================================================================
        )");
        blank();
    }

    void write_project() {
        emit(R"(
            cmake_minimum_required(VERSION 3.16)
            project(${MODULE}_python VERSION ${VERSION} LANGUAGES CXX)

            set(CMAKE_CXX_STANDARD 20)
            set(CMAKE_CXX_STANDARD_REQUIRED ON)
            set(CMAKE_POSITION_INDEPENDENT_CODE ON)

            set(MODULE_NAME "${MODULE}")
        )",
             {{"MODULE", config_.module_name}, {"VERSION", config_.version}});
        blank();
    }

    void write_python_config() {
        if (!config_.python_executable.empty()) {
            emit(R"(
                # Use specified Python installation
                # This can be a root directory (e.g., /Library/Frameworks/Python.framework/Versions/3.12)
                # or an executable path (e.g., /usr/bin/python3.11)
                set(Python_ROOT_DIR "${PYTHON_PATH}")
                set(Python_FIND_STRATEGY LOCATION)
                set(Python_FIND_REGISTRY NEVER)
            )",
                 {{"PYTHON_PATH", config_.python_executable}});
            blank();
        }

        emit(R"(
            # Find Python
            find_package(Python REQUIRED COMPONENTS Interpreter Development)
        )");
        blank();
    }

    void write_sources() {
        line("# ==================================================");
        line("# Source Files");
        line("# ==================================================");

        // Static compilation: declare library source files
        if (config_.should_compile_sources() && !config_.source_files.empty()) {
            line("# Third-party/library source files (static compilation)");
            cmake_set("LIB_SOURCES", [&]() { quoted_lines(config_.source_files); });
            blank();
        }

        line("# Generated binding source");
        cmake_set("BINDING_SOURCES",
                  [&]() { line("${CMAKE_CURRENT_SOURCE_DIR}/generated_pybind11.cxx"); });
        blank();
    }

    void write_pybind11_config() {
        emit(R"(
            # Find or fetch pybind11
            find_package(pybind11 CONFIG QUIET)
        )");

        cmake_if("NOT pybind11_FOUND", [&]() {
            emit(R"(
                include(FetchContent)
                FetchContent_Declare(
                    pybind11
                    GIT_REPOSITORY https://github.com/pybind/pybind11.git
                    GIT_TAG v2.11.1
                )
                FetchContent_MakeAvailable(pybind11)
            )");
        });
        blank();
    }

    void write_module() {
        line("# Create Python module");

        if (config_.should_compile_sources() && !config_.source_files.empty()) {
            line("# Static compilation mode - compile all sources into module");
            block("pybind11_add_module(${MODULE_NAME}", ")", [&]() {
                line("${BINDING_SOURCES}");
                line("${LIB_SOURCES}");
            });
        } else {
            line("# Dynamic linking mode - link against pre-built library");
            block("pybind11_add_module(${MODULE_NAME}", ")", [&]() { line("${BINDING_SOURCES}"); });
        }
        blank();

        // Include directories
        cmake_target_block("target_include_directories", "${MODULE_NAME}", "PRIVATE", [&]() {
            line("${CMAKE_CURRENT_SOURCE_DIR}");
            quoted_lines(config_.include_dirs);
        });
        blank();

        // Library directories (for dynamic linking)
        if (config_.should_link_library() && !config_.library_dirs.empty()) {
            cmake_target_block("target_link_directories", "${MODULE_NAME}", "PRIVATE",
                               [&]() { quoted_lines(config_.library_dirs); });
            blank();
        }

        // Link libraries (for dynamic linking)
        if (config_.should_link_library() && !config_.link_libraries.empty()) {
            cmake_target_block("target_link_libraries", "${MODULE_NAME}", "PRIVATE",
                               [&]() { lines(config_.link_libraries); });
            blank();
        }

        // Compile definitions
        if (!config_.defines.empty()) {
            cmake_target_block("target_compile_definitions", "${MODULE_NAME}", "PRIVATE",
                               [&]() {
                                   for (const auto &def : config_.defines) {
                                       line(def.to_cmake_string());
                                   }
                               });
            blank();
        }

        // Platform-specific settings
        cmake_if("WIN32 AND Python_LIBRARIES", [&]() {
            line("target_link_libraries(${MODULE_NAME} PRIVATE ${Python_LIBRARIES})");
        });
        blank();

        block("set_target_properties(${MODULE_NAME} PROPERTIES", ")", [&]() {
            line("LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}\"");
            line("RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}\"");
        });
        blank();

        cmake_if("WIN32", [&]() {
            line("set_target_properties(${MODULE_NAME} PROPERTIES SUFFIX \".pyd\")");
        });
        blank();
    }

    void write_install() {
        line("# Installation");
        block("install(TARGETS ${MODULE_NAME}", ")", [&]() {
            line("LIBRARY DESTINATION .");
            line("RUNTIME DESTINATION .");
        });
        blank();

        if (config_.generate_stubs) {
            line("# Install type stubs");
            block("install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/${MODULE_NAME}.pyi", ")",
                  [&]() { line("DESTINATION ."); });
        }
    }
};