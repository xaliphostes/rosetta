#pragma once
#include "../common/CodeWriter.h"
#include <algorithm>
#include <map>
#include <rosetta/core/function_registry.h>
#include <rosetta/rosetta.h>
#include <typeindex>

// ============================================================================
// Pybind11Generator - Modernized with emit() and block helpers
// ============================================================================
// UPDATED: Properly handles overloaded and aliased free functions.
// 
// Free function binding strategy:
// - Non-overloaded: m.def("name", &name);
// - Overloaded:     m.def("name", static_cast<Type>(&name));
// - Aliased:        m.def("alias", static_cast<Type>(&cpp_name));
//
// The is_overloaded() flag from FunctionMetadata determines which form to use.
// ============================================================================

class Pybind11Generator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_numpy_helpers();
        write_module();
    }

private:
    using ConstructorMeta = rosetta::core::Registry::MetadataHolder::ConstructorMeta;
    using MethodMeta      = rosetta::core::Registry::MetadataHolder::MethodMeta;
    using PropertyMeta    = rosetta::core::Registry::MetadataHolder::PropertyMeta;

    void write_header() {
        emit(R"(
// ============================================================================
// AUTO-GENERATED PYBIND11 BINDINGS - DO NOT EDIT
// Generated by binding_generator from Rosetta introspection
// ============================================================================
)");
    }

    void write_includes() {
        emit(R"(
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>
#include <pybind11/functional.h>
#include <pybind11/operators.h>
#include <filesystem>

#include <rosetta/rosetta.h>

// Project headers
)");

        for (const auto &header : config_.source_headers) {
            line("#include <" + header + ">");
        }
        blank();

        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
        }

        // Add type caster for std::filesystem::path
        emit(R"(
// ============================================================================
// Custom type caster for std::filesystem::path
// Allows automatic conversion between Python str and std::filesystem::path
// ============================================================================
namespace pybind11 { namespace detail {

template <>
struct type_caster<std::filesystem::path> {
public:
    PYBIND11_TYPE_CASTER(std::filesystem::path, const_name("os.PathLike"));

    // Python -> C++
    bool load(handle src, bool) {
        PyObject* obj = src.ptr();
        
        // Handle pathlib.Path and os.PathLike objects
        if (hasattr(src, "__fspath__")) {
            PyObject* path_str = PyOS_FSPath(obj);
            if (!path_str) return false;
            
            if (PyUnicode_Check(path_str)) {
                value = std::filesystem::path(PyUnicode_AsUTF8(path_str));
                Py_DECREF(path_str);
                return true;
            }
            Py_DECREF(path_str);
        }
        
        // Handle plain strings
        if (PyUnicode_Check(obj)) {
            value = std::filesystem::path(PyUnicode_AsUTF8(obj));
            return true;
        }
        
        // Handle bytes
        if (PyBytes_Check(obj)) {
            value = std::filesystem::path(PyBytes_AsString(obj));
            return true;
        }
        
        return false;
    }

    // C++ -> Python
    static handle cast(const std::filesystem::path& path, return_value_policy, handle) {
        return PyUnicode_FromString(path.string().c_str());
    }
};

}} // namespace pybind11::detail

namespace py = pybind11;
using namespace pybind11::literals;
)");
    }

    void write_numpy_helpers() {
        emit(R"(
// ============================================================================
// NumPy <-> C++ conversion helpers
// ============================================================================
namespace {

py::array_t<double> vector_double_to_numpy(const std::vector<double>& vec) {
    return py::array_t<double>(vec.size(), vec.data());
}

std::vector<double> numpy_to_vector_double(py::array_t<double> arr) {
    auto buf = arr.unchecked<1>();
    return std::vector<double>(buf.data(0), buf.data(0) + buf.size());
}

py::array_t<int> vector_int_to_numpy(const std::vector<int>& vec) {
    return py::array_t<int>(vec.size(), vec.data());
}

std::vector<int> numpy_to_vector_int(py::array_t<int> arr) {
    auto buf = arr.unchecked<1>();
    return std::vector<int>(buf.data(0), buf.data(0) + buf.size());
}

} // anonymous namespace
)");
    }

    void write_module() {
        emit(R"(
// ============================================================================
// Pybind11 Module Definition
// ============================================================================
)");

        line("PYBIND11_MODULE(" + config_.module_name + ", m) {");
        with_indent([&]() {
            line("m.doc() = \"" + config_.description + "\";");
            blank();
            line("// Register Rosetta classes");
            line(config_.get_registration_call() + ";");
            blank();

            auto &registry    = rosetta::Registry::instance();
            auto  class_names = registry.list_classes();
            auto  sorted      = topological_sort(class_names, registry);

            for (const auto &name : sorted) {
                auto *holder = registry.get_by_name(name);
                if (holder)
                    write_class_binding(name, holder);
            }

            write_free_functions();
            write_utility_functions();
        });
        line("}");
    }

    std::vector<std::string> topological_sort(const std::vector<std::string> &names,
                                              rosetta::Registry              &registry) {
        std::vector<std::string> sorted;
        std::set<std::string>    visited;
        std::set<std::string>    name_set(names.begin(), names.end());

        std::map<std::string, std::string> short_to_full;
        for (const auto &n : names) {
            size_t      pos           = n.rfind("::");
            std::string short_name    = (pos != std::string::npos) ? n.substr(pos + 2) : n;
            short_to_full[short_name] = n;
        }

        std::function<void(const std::string &)> visit = [&](const std::string &n) {
            if (visited.count(n))
                return;
            visited.insert(n);
            auto *h = registry.get_by_name(n);
            if (h) {
                auto base = h->get_base_class();
                if (!base.empty()) {
                    if (name_set.count(base)) {
                        visit(base);
                    } else {
                        size_t      pos = base.rfind("::");
                        std::string base_short =
                            (pos != std::string::npos) ? base.substr(pos + 2) : base;
                        auto it = short_to_full.find(base_short);
                        if (it != short_to_full.end() && name_set.count(it->second)) {
                            visit(it->second);
                        }
                    }
                }
            }
            sorted.push_back(n);
        };

        for (const auto &n : names)
            visit(n);
        return sorted;
    }

    void write_class_binding(const std::string                             &name,
                             const rosetta::core::Registry::MetadataHolder *holder) {
        if (config_.should_skip_class(name)) {
            line("// Skipped: " + name);
            return;
        }

        std::string py_name  = config_.binding_name(name);
        std::string cpp_type = holder->get_cpp_type_name();
        auto        base     = holder->get_base_class();

        line("// --- " + py_name + " ---");

        std::string base_spec = base.empty() ? "" : ", " + base;
        line("py::class_<" + cpp_type + base_spec + ", std::shared_ptr<" + cpp_type + ">>(m, \"" +
             py_name + "\")");

        with_indent([&]() {
            // Constructors
            for (const auto &ctor : holder->get_constructors()) {
                write_constructor(cpp_type, ctor);
            }

            // Fields
            for (const auto &field : holder->get_fields()) {
                if (!config_.should_skip_method(name, field)) {
                    write_field(cpp_type, field, holder);
                }
            }

            // Properties
            for (const auto &prop_name : holder->get_properties()) {
                if (!config_.should_skip_method(name, prop_name)) {
                    write_property(cpp_type, holder->get_property_info(prop_name), holder);
                }
            }

            // Methods
            for (const auto &method : holder->get_methods()) {
                if (!config_.should_skip_method(name, method)) {
                    write_method(cpp_type, method, holder);
                }
            }

            line(";");
        });
        blank();
    }

    void write_constructor(const std::string &cpp_type, const ConstructorMeta &ctor) {
        // Handle lambda constructors - use the provided lambda body directly
        if (ctor.is_lambda && !ctor.lambda_body.empty()) {
            line(".def(py::init(" + ctor.lambda_body + "))");
            return;
        }

        auto params = ctor.get_param_types();
        if (params.empty()) {
            line(".def(py::init<>())");
            return;
        }

        bool needs_numpy = std::any_of(params.begin(), params.end(), [this](const std::string &p) {
            return needs_numpy_conversion(p);
        });
        bool has_ref     = std::any_of(params.begin(), params.end(),
                                       [this](const std::string &p) { return has_reference_param(p); });

        if (needs_numpy || has_ref) {
            write_constructor_wrapper(cpp_type, params);
        } else {
            line(".def(py::init<" + join_types(params) + ">())");
        }
    }

    void write_constructor_wrapper(const std::string              &cpp_type,
                                   const std::vector<std::string> &params) {
        std::ostringstream w;
        w << ".def(py::init([](";

        std::vector<std::string> fwd;
        for (size_t i = 0; i < params.size(); ++i) {
            if (i > 0)
                w << ", ";
            w << get_constructor_param_type(params[i]) << " arg" << i;
            fwd.push_back(generate_input_conversion(params[i], "arg" + std::to_string(i)));
        }

        w << ") { return std::make_shared<" << cpp_type << ">(";
        for (size_t i = 0; i < fwd.size(); ++i) {
            if (i > 0)
                w << ", ";
            w << fwd[i];
        }
        w << "); }))";
        line(w.str());
    }

    void write_field(const std::string &cpp_type, const std::string &field_name,
                     const rosetta::core::Registry::MetadataHolder *holder) {
        std::type_index field_type = holder->get_field_type(field_name);
        std::string     type_str   = rosetta::demangle(field_type.name());

        if (needs_numpy_conversion(type_str)) {
            emit(R"(
.def_property("${FIELD}",
        [](const ${TYPE}& self) {
            return ${OUTPUT};
        },
        [](${TYPE}& self, ${PARAM_TYPE} val) {
            self.${FIELD} = ${INPUT};
        }))",
                 {{"FIELD", field_name},
                  {"TYPE", cpp_type},
                  {"OUTPUT", generate_output_conversion(type_str, "self." + field_name)},
                  {"PARAM_TYPE", get_python_param_type(type_str)},
                  {"INPUT", generate_input_conversion(type_str, "val")}});
        } else {
            line(".def_readwrite(\"" + field_name + "\", &" + cpp_type + "::" + field_name + ")");
        }
    }

    void write_property(const std::string &cpp_type, const PropertyMeta &prop,
                        const rosetta::core::Registry::MetadataHolder *holder) {
        std::string type_str  = prop.get_value_type_str();
        std::string norm_type = normalize_type(type_str);
        std::string cap_name  = capitalize(prop.name);

        if (prop.is_readonly) {
            emit(R"(
.def_property_readonly("${NAME}",
        [](const ${TYPE}& self) {
            return ${OUTPUT};
        }))",
                 {{"NAME", prop.name},
                  {"TYPE", cpp_type},
                  {"OUTPUT", generate_output_conversion(type_str, "self.get" + cap_name + "()")}});
        } else if (prop.is_writeonly) {
            emit(R"(
.def_property("${NAME}",
        [](const ${TYPE}&) -> ${NORM_TYPE} {
            throw std::runtime_error("Property ${NAME} is write-only");
        },
        [](${TYPE}& self, ${NORM_TYPE} val) {
            self.set${CAP_NAME}(val);
        }))",
                 {{"NAME", prop.name},
                  {"TYPE", cpp_type},
                  {"NORM_TYPE", norm_type},
                  {"CAP_NAME", cap_name}});
        } else if (needs_numpy_conversion(type_str)) {
            emit(R"(
.def_property("${NAME}",
        [](const ${TYPE}& self) {
            return ${OUTPUT};
        },
        [](${TYPE}& self, ${PARAM_TYPE} val) {
            self.set${CAP_NAME}(${INPUT});
        }))",
                 {{"NAME", prop.name},
                  {"TYPE", cpp_type},
                  {"OUTPUT", generate_output_conversion(type_str, "self.get" + cap_name + "()")},
                  {"PARAM_TYPE", get_python_param_type(type_str)},
                  {"CAP_NAME", cap_name},
                  {"INPUT", generate_input_conversion(type_str, "val")}});
        } else {
            emit(R"(
.def_property("${NAME}",
        [](const ${TYPE}& self) {
            return self.get${CAP_NAME}();
        },
        [](${TYPE}& self, const ${NORM_TYPE}& val) {
            self.set${CAP_NAME}(val);
        }))",
                 {{"NAME", prop.name},
                  {"TYPE", cpp_type},
                  {"NORM_TYPE", norm_type},
                  {"CAP_NAME", cap_name}});
        }
    }

    void write_method(const std::string &cpp_type, const std::string &name,
                      const rosetta::core::Registry::MetadataHolder *holder) {
        auto info        = holder->get_method_info(name);
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        if (info.is_lambda) {
            write_lambda_method(cpp_type, name, info);
        } else if (info.is_overloaded || needs_numpy_wrapper(return_type, param_types)) {
            write_wrapped_method(cpp_type, name, info);
        } else {
            std::string policy = get_return_policy(return_type);
            if (!policy.empty()) {
                line(".def(\"" + name + "\", &" + cpp_type + "::" + name + ", " + policy + ")");
            } else {
                line(".def(\"" + name + "\", &" + cpp_type + "::" + name + ")");
            }
        }
    }

    void write_lambda_method(const std::string &cpp_type, const std::string &name,
                             const MethodMeta &info) {
        auto        param_types = info.get_param_types_str();
        auto        return_type = info.get_return_type_str();
        std::string self_type   = info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        std::ostringstream w;
        w << ".def(\"" << name << "\", [](" << self_type << " self";
        for (size_t i = 0; i < param_types.size(); ++i) {
            w << ", " << get_python_param_type(param_types[i]) << " arg" << i;
        }
        w << ") {\n";
        w << "            std::vector<rosetta::Any> args;\n";
        if (!param_types.empty()) {
            w << "            args.reserve(" << param_types.size() << ");\n";
        }
        for (size_t i = 0; i < param_types.size(); ++i) {
            w << "            args.emplace_back("
              << generate_input_conversion(param_types[i], "arg" + std::to_string(i)) << ");\n";
        }

        w << "            auto& meta = rosetta::Registry::instance().get<" << cpp_type << ">();\n";

        std::string cast = info.is_const ? "static_cast<const " + cpp_type + "&>(self)" : "self";
        if (return_type == "void") {
            w << "            meta.invoke_method(" << cast << ", \"" << name
              << "\", std::move(args));\n";
        } else {
            w << "            auto result = meta.invoke_method(" << cast << ", \"" << name
              << "\", std::move(args));\n";
            w << "            return "
              << generate_output_conversion(return_type,
                                            "result.as<" + normalize_type(return_type) + ">()")
              << ";\n";
        }
        w << "        })";
        line(w.str());
    }

    void write_wrapped_method(const std::string &cpp_type, const std::string &name,
                              const MethodMeta &info) {
        auto        param_types = info.get_param_types_str();
        auto        return_type = info.get_return_type_str();
        std::string self        = info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        std::ostringstream w;
        w << ".def(\"" << name << "\", [](" << self << " self";
        for (size_t i = 0; i < param_types.size(); ++i) {
            w << ", " << get_python_param_type(param_types[i]) << " arg" << i;
        }
        w << ") {\n";

        std::string call = "self." + name + "(";
        for (size_t i = 0; i < param_types.size(); ++i) {
            if (i > 0)
                call += ", ";
            call += generate_input_conversion(param_types[i], "arg" + std::to_string(i));
        }
        call += ")";

        if (return_type == "void") {
            w << "            " << call << ";\n";
        } else {
            w << "            auto result = " << call << ";\n";
            w << "            return " << generate_output_conversion(return_type, "result")
              << ";\n";
        }
        w << "        })";
        line(w.str());
    }

    // ========================================================================
    // Free Functions Support - PROPERLY HANDLES OVERLOADS
    // ========================================================================
    // 
    // Strategy based on FunctionMetadata flags:
    // 1. is_overloaded() == false: use simple &func_name
    // 2. is_overloaded() == true:  use static_cast<Type>(&cpp_name)
    //
    // The is_overloaded flag is set by:
    // - register_function(): sets is_overloaded = false
    // - register_overloaded_function(): sets is_overloaded = true
    // - register_function_as(): sets is_overloaded = true (aliased implies overloaded)
    // ========================================================================

    void write_free_functions() {
        auto &func_registry  = rosetta::core::FunctionRegistry::instance();
        auto  function_names = func_registry.list_functions();

        if (function_names.empty())
            return;

        emit(R"(
// ============================================================================
// Free Functions
// ============================================================================
)");

        for (const auto &func_name : function_names) {
            if (config_.should_skip_method("", func_name))
                continue;

            const auto &func_meta = func_registry.get(func_name);

            // Get type information from metadata
            std::vector<std::string> param_types;
            for (const auto &ti : func_meta.param_types()) {
                param_types.push_back(rosetta::demangle(ti.name()));
            }
            std::string return_type = rosetta::demangle(func_meta.return_type().name());

            if (needs_numpy_wrapper(return_type, param_types)) {
                write_wrapped_free_function(func_name, func_meta, param_types, return_type);
            } else {
                write_simple_free_function(func_meta);
            }
        }
        blank();
    }

    /**
     * @brief Write a simple free function binding
     * 
     * - If is_overloaded() == false: use simple &func_name
     * - If is_overloaded() == true:  use static_cast with stored type string
     */
    /**
     * @brief Extract the simple name from a possibly qualified name
     * 
     * Strips namespace prefixes: "pmp::triangulate" -> "triangulate"
     */
    static std::string extract_simple_name(const std::string &qualified_name) {
        auto pos = qualified_name.rfind("::");
        return (pos != std::string::npos) ? qualified_name.substr(pos + 2) : qualified_name;
    }

    /**
     * @brief Write a simple free function binding
     * 
     * - If is_overloaded() == false: use simple &func_name
     * - If is_overloaded() == true:  use static_cast with stored type string
     * 
     * The Python name is always the simple name (without namespace).
     * The C++ name keeps its full qualification.
     */
    void write_simple_free_function(const rosetta::core::FunctionMetadata &func_meta) {
        // Python name: strip namespace prefix
        std::string py_name = extract_simple_name(func_meta.name());
        // C++ name: keep full qualification for the & reference
        const std::string &cpp_name = func_meta.cpp_name();
        
        if (func_meta.is_overloaded()) {
            // Overloaded or aliased function: MUST use static_cast
            // Use the stored type string (from registration macro)
            std::string func_ptr_type = func_meta.func_ptr_type_str();
            
            if (func_ptr_type.empty()) {
                // Fallback: try to build from type info (may not work for const& types)
                func_ptr_type = build_function_ptr_type(func_meta);
            }
            
            // Generate: m.def("py_name", static_cast<type>(&cpp_name));
            line("m.def(\"" + py_name + "\", static_cast<" + func_ptr_type + ">(&" + cpp_name + "));");
        } else {
            // Non-overloaded function: use simple form
            // Generate: m.def("name", &name);
            line("m.def(\"" + py_name + "\", &" + cpp_name + ");");
        }
    }

    /**
     * @brief Build a function pointer type string for static_cast
     * 
     * Converts the stored type information into a valid C++ function pointer type.
     * Handles platform-specific demangled names.
     */
    std::string build_function_ptr_type(const rosetta::core::FunctionMetadata &func_meta) {
        std::string ret_type = fix_type_for_source(rosetta::demangle(func_meta.return_type().name()));
        
        std::vector<std::string> params;
        for (const auto &ti : func_meta.param_types()) {
            params.push_back(fix_type_for_source(rosetta::demangle(ti.name())));
        }
        
        // Build: RetType(*)(Arg1, Arg2, ...)
        std::string result = ret_type + "(*)(";
        for (size_t i = 0; i < params.size(); ++i) {
            if (i > 0) result += ", ";
            result += params[i];
        }
        result += ")";
        
        return result;
    }

    /**
     * @brief Fix demangled type names to be valid C++ source code
     * 
     * The demangler may produce platform-specific internal names that are not
     * valid in source code. This function normalizes them.
     */
    std::string fix_type_for_source(const std::string &t) {
        std::string r = t;
        size_t pos;
        
        // ================================================================
        // Fix libc++ internal namespaces (macOS/clang)
        // ================================================================
        while ((pos = r.find("std::__1::")) != std::string::npos)
            r.replace(pos, 10, "std::");
        
        // ================================================================
        // Fix libstdc++ internal namespaces (Linux/GCC)
        // ================================================================
        while ((pos = r.find("std::__cxx11::")) != std::string::npos)
            r.replace(pos, 14, "std::");
        
        // ================================================================
        // Fix filesystem paths - handle various demangled forms
        // ================================================================
        // macOS libc++ uses: std::__fs::filesystem::path
        // Some versions use: __fs::filesystem::path
        // We want: std::filesystem::path
        
        // Handle std::__fs::filesystem -> std::filesystem
        while ((pos = r.find("std::__fs::filesystem")) != std::string::npos)
            r.replace(pos, 21, "std::filesystem");
        
        // Handle __fs::filesystem without std:: prefix
        while ((pos = r.find("__fs::filesystem")) != std::string::npos)
            r.replace(pos, 16, "std::filesystem");
        
        // Handle potential std::fs::filesystem (in case it appears)
        while ((pos = r.find("std::fs::filesystem")) != std::string::npos)
            r.replace(pos, 19, "std::filesystem");
            
        // ================================================================
        // Fix basic_string variants
        // ================================================================
        // Full form with traits and allocator
        while ((pos = r.find("std::basic_string<char, std::char_traits<char>, std::allocator<char>>")) != std::string::npos)
            r.replace(pos, 69, "std::string");
        
        // Partial form
        while ((pos = r.find("std::basic_string<char, std::char_traits<char>>")) != std::string::npos)
            r.replace(pos, 47, "std::string");
        
        // Simple form
        while ((pos = r.find("std::basic_string<char>")) != std::string::npos)
            r.replace(pos, 23, "std::string");
        
        while ((pos = r.find("basic_string<char>")) != std::string::npos)
            r.replace(pos, 18, "std::string");
        
        // ================================================================
        // Remove allocator from containers
        // std::vector<T, std::allocator<T>> -> std::vector<T>
        // ================================================================
        size_t alloc_start;
        while ((alloc_start = r.find(", std::allocator<")) != std::string::npos) {
            size_t depth = 1, alloc_end = alloc_start + 17;
            while (alloc_end < r.size() && depth > 0) {
                if (r[alloc_end] == '<') depth++;
                else if (r[alloc_end] == '>') depth--;
                alloc_end++;
            }
            r.erase(alloc_start, alloc_end - alloc_start);
        }
        
        return r;
    }

    /**
     * @brief Write a wrapped free function (for numpy conversion)
     */
    void write_wrapped_free_function(const std::string &func_name,
                                     const rosetta::core::FunctionMetadata &func_meta,
                                     const std::vector<std::string> &param_types,
                                     const std::string              &return_type) {
        const std::string &py_name = func_meta.name();
        const std::string &cpp_name = func_meta.cpp_name();
        
        std::ostringstream w;
        w << "m.def(\"" << py_name << "\", [](";

        std::vector<std::string> args;
        for (size_t i = 0; i < param_types.size(); ++i) {
            if (i > 0)
                w << ", ";
            w << get_python_param_type(param_types[i]) << " arg" << i;
            args.push_back(generate_input_conversion(param_types[i], "arg" + std::to_string(i)));
        }
        w << ") {\n";

        if (return_type == "void") {
            w << "        " << cpp_name << "(" << join(args, ", ") << ");\n";
        } else {
            w << "        auto result = " << cpp_name << "(" << join(args, ", ") << ");\n";
            w << "        return " << generate_output_conversion(return_type, "result") << ";\n";
        }
        w << "    });";
        line(w.str());
    }

    void write_utility_functions() {
        emit(R"(
// Utilities
m.def("list_classes", []() { return rosetta::Registry::instance().list_classes(); });
m.def("list_functions", []() { return rosetta::core::FunctionRegistry::instance().list_functions(); });
m.def("get_class_methods", [](const std::string& n) {
    auto* h = rosetta::Registry::instance().get_by_name(n);
    if (!h) throw std::runtime_error("Class not found: " + n);
    return h->get_methods();
});
m.def("get_class_fields", [](const std::string& n) {
    auto* h = rosetta::Registry::instance().get_by_name(n);
    if (!h) throw std::runtime_error("Class not found: " + n);
    return h->get_fields();
});
m.def("get_class_properties", [](const std::string& n) {
    auto* h = rosetta::Registry::instance().get_by_name(n);
    if (!h) throw std::runtime_error("Class not found: " + n);
    return h->get_properties();
});
m.def("version", []() { return rosetta::version(); });
)");
    }

    // ========================================================================
    // Helper methods
    // ========================================================================

    std::string capitalize(const std::string &s) {
        if (s.empty())
            return s;
        std::string result = s;
        result[0]          = std::toupper(result[0]);
        return result;
    }

    bool has_reference_param(const std::string &t) {
        std::string s = t;
        size_t      pos;
        while ((pos = s.find("&&")) != std::string::npos)
            s.erase(pos, 2);
        return s.find('&') != std::string::npos;
    }

    bool needs_numpy_conversion(const std::string &t) {
        std::string norm = normalize_type(t);
        return norm.find("vector<double>") != std::string::npos ||
               norm.find("vector<int>") != std::string::npos ||
               norm.find("vector<float>") != std::string::npos;
    }

    bool needs_numpy_wrapper(const std::string &ret, const std::vector<std::string> &params) {
        if (needs_numpy_conversion(ret))
            return true;
        return std::any_of(params.begin(), params.end(),
                           [this](const std::string &p) { return needs_numpy_conversion(p); });
    }

    std::string normalize_type(const std::string &t) {
        std::string r = t;
        size_t      pos;

        while ((pos = r.find("std::__1::")) != std::string::npos)
            r.replace(pos, 10, "std::");

        size_t alloc_start;
        while ((alloc_start = r.find(", std::allocator<")) != std::string::npos) {
            size_t depth = 1, alloc_end = alloc_start + 17;
            while (alloc_end < r.size() && depth > 0) {
                if (r[alloc_end] == '<')
                    depth++;
                else if (r[alloc_end] == '>')
                    depth--;
                alloc_end++;
            }
            r.erase(alloc_start, alloc_end - alloc_start);
        }

        while ((pos = r.find(", std::char_traits<char>")) != std::string::npos)
            r.erase(pos, 24);
        while ((pos = r.find("std::basic_string<char>")) != std::string::npos)
            r.replace(pos, 23, "std::string");
        while ((pos = r.find("basic_string<char>")) != std::string::npos)
            r.replace(pos, 18, "std::string");

        for (const auto &s : {"const ", "&"}) {
            while ((pos = r.find(s)) != std::string::npos)
                r.erase(pos, strlen(s));
        }

        while (!r.empty() && r[0] == ' ')
            r.erase(0, 1);
        while (!r.empty() && r.back() == ' ')
            r.pop_back();
        return r;
    }

    std::string join_types(const std::vector<std::string> &types) {
        std::string result;
        for (size_t i = 0; i < types.size(); ++i) {
            if (i > 0)
                result += ", ";
            result += normalize_type(types[i]);
        }
        return result;
    }

    std::string get_constructor_param_type(const std::string &t) {
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "py::array_t<double>";
        if (norm.find("vector<int>") != std::string::npos)
            return "py::array_t<int>";
        if (has_reference_param(t)) {
            std::string cleaned = t;
            size_t      pos;
            while ((pos = cleaned.find("std::__1::")) != std::string::npos)
                cleaned.replace(pos, 10, "std::");
            return cleaned;
        }
        return norm;
    }

    std::string get_python_param_type(const std::string &t) {
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "py::array_t<double>";
        if (norm.find("vector<int>") != std::string::npos)
            return "py::array_t<int>";
        if (norm.find("function") != std::string::npos)
            return "std::function<Point(const Point&)>";
        return norm;
    }

    std::string generate_input_conversion(const std::string &t, const std::string &v) {
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "numpy_to_vector_double(" + v + ")";
        if (norm.find("vector<int>") != std::string::npos)
            return "numpy_to_vector_int(" + v + ")";
        return v;
    }

    std::string generate_output_conversion(const std::string &t, const std::string &v) {
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "vector_double_to_numpy(" + v + ")";
        if (norm.find("vector<int>") != std::string::npos)
            return "vector_int_to_numpy(" + v + ")";
        return v;
    }

    std::string get_return_policy(const std::string &t) {
        if (t.find("*") != std::string::npos)
            return "py::return_value_policy::reference_internal";
        if (t.find("&") != std::string::npos && t.find("const") == std::string::npos)
            return "py::return_value_policy::reference_internal";
        return "";
    }
};