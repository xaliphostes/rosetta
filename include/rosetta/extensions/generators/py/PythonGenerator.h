#pragma once
#include "../common/CodeWriter.h"
#include <rosetta/rosetta.h>
#include <typeindex>
#include <algorithm>
#include <map>

// ============================================================================
// Pybind11Generator - Uses Rosetta's native field/property separation
// ============================================================================

class Pybind11Generator : public CodeWriter {
  public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_numpy_helpers();
        write_module();
    }

  private:
    using ConstructorMeta = rosetta::core::Registry::MetadataHolder::ConstructorMeta;
    using MethodMeta = rosetta::core::Registry::MetadataHolder::MethodMeta;
    using PropertyMeta = rosetta::core::Registry::MetadataHolder::PropertyMeta;

    void write_header() {
        line("// ============================================================================");
        line("// AUTO-GENERATED PYBIND11 BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// ============================================================================");
        line();
    }

    void write_includes() {
        line("#include <pybind11/pybind11.h>");
        line("#include <pybind11/stl.h>");
        line("#include <pybind11/numpy.h>");
        line("#include <pybind11/functional.h>");
        line("#include <pybind11/operators.h>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();
        line("// Project headers");
        for (const auto &header : config_.source_headers) {
            line("#include <" + header + ">");
        }
        line();
        
        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
        }
        line();
        line("namespace py = pybind11;");
        line("using namespace pybind11::literals;");
        line();
    }

    void write_numpy_helpers() {
        line("// ============================================================================");
        line("// NumPy <-> C++ conversion helpers");
        line("// ============================================================================");
        line("namespace {");
        line();
        indent();

        line("py::array_t<double> vector_double_to_numpy(const std::vector<double>& vec) {");
        indent();
        line("return py::array_t<double>(vec.size(), vec.data());");
        dedent();
        line("}");
        line();

        line("std::vector<double> numpy_to_vector_double(py::array_t<double> arr) {");
        indent();
        line("auto buf = arr.unchecked<1>();");
        line("return std::vector<double>(buf.data(0), buf.data(0) + buf.size());");
        dedent();
        line("}");
        line();

        line("py::array_t<int> vector_int_to_numpy(const std::vector<int>& vec) {");
        indent();
        line("return py::array_t<int>(vec.size(), vec.data());");
        dedent();
        line("}");
        line();

        line("std::vector<int> numpy_to_vector_int(py::array_t<int> arr) {");
        indent();
        line("auto buf = arr.unchecked<1>();");
        line("return std::vector<int>(buf.data(0), buf.data(0) + buf.size());");
        dedent();
        line("}");

        dedent();
        line();
        line("} // anonymous namespace");
        line();
    }

    void write_module() {
        line("// ============================================================================");
        line("// Pybind11 Module Definition");
        line("// ============================================================================");
        line();
        line("PYBIND11_MODULE(" + config_.module_name + ", m) {");
        indent();
        line("m.doc() = \"" + config_.description + "\";");
        line();
        line("// Register Rosetta classes");
        line(config_.get_registration_call() + ";");
        line();

        auto &registry = rosetta::Registry::instance();
        auto class_names = registry.list_classes();
        auto sorted = topological_sort(class_names, registry);

        for (const auto &name : sorted) {
            auto *holder = registry.get_by_name(name);
            if (holder)
                write_class_binding(name, holder);
        }

        write_utility_functions();

        dedent();
        line("}");
    }

    std::vector<std::string>
    topological_sort(const std::vector<std::string> &names,
                     rosetta::Registry &registry) {
        std::vector<std::string> sorted;
        std::set<std::string> visited;
        std::set<std::string> name_set(names.begin(), names.end());
        
        // Build a map from short names to full names for lookup
        std::map<std::string, std::string> short_to_full;
        for (const auto &n : names) {
            size_t pos = n.rfind("::");
            std::string short_name = (pos != std::string::npos) ? n.substr(pos + 2) : n;
            short_to_full[short_name] = n;
        }

        std::function<void(const std::string &)> visit =
            [&](const std::string &n) {
                if (visited.count(n))
                    return;
                visited.insert(n);
                auto *h = registry.get_by_name(n);
                if (h) {
                    auto base = h->get_base_class();
                    if (!base.empty()) {
                        // Try to find the base class in our registered classes
                        // First try the full name
                        if (name_set.count(base)) {
                            visit(base);
                        } else {
                            // Try the short name
                            size_t pos = base.rfind("::");
                            std::string base_short = (pos != std::string::npos)
                                                        ? base.substr(pos + 2)
                                                        : base;
                            // Look up if there's a registered class with this short name
                            auto it = short_to_full.find(base_short);
                            if (it != short_to_full.end() && name_set.count(it->second)) {
                                visit(it->second);
                            }
                        }
                    }
                }
                sorted.push_back(n);
            };

        for (const auto &n : names)
            visit(n);
        return sorted;
    }

    void write_class_binding(const std::string &name,
                             const rosetta::core::Registry::MetadataHolder *holder) {
        if (config_.should_skip_class(name)) {
            line("// Skipped: " + name);
            return;
        }

        // Get the Python binding name (with namespace handling)
        std::string py_name = config_.binding_name(name);
        
        line("// --- " + py_name + " ---");
        std::string cpp_type = holder->get_cpp_type_name();
        auto base = holder->get_base_class();

        std::string base_spec;
        if (!base.empty()) {
            base_spec = ", " + base;
        }

        line("py::class_<" + cpp_type + base_spec + ", std::shared_ptr<" + cpp_type + ">>(m, \"" + py_name + "\")");
        indent();

        // Constructors
        for (const auto &ctor : holder->get_constructors()) {
            write_constructor(cpp_type, ctor);
        }

        // Fields (actual C++ member fields)
        for (const auto &field : holder->get_fields()) {
            if (!config_.should_skip_method(name, field)) {
                write_field(cpp_type, field, holder);
            }
        }

        // Properties (virtual fields via getter/setter) - using new Rosetta API!
        for (const auto &prop_name : holder->get_properties()) {
            if (!config_.should_skip_method(name, prop_name)) {
                auto prop_info = holder->get_property_info(prop_name);
                write_property(cpp_type, prop_info, holder);
            }
        }

        // Methods
        for (const auto &method : holder->get_methods()) {
            if (!config_.should_skip_method(name, method)) {
                write_method(cpp_type, method, holder);
            }
        }

        line(";");
        dedent();
        line();
    }

    void write_constructor(const std::string &cpp_type,
                           const ConstructorMeta &ctor) {
        auto params = ctor.get_param_types();
        if (params.empty()) {
            line(".def(py::init<>())");
        } else {
            bool needs_numpy = std::any_of(
                params.begin(), params.end(), [this](const std::string &p) {
                    return needs_numpy_conversion(p);
                });

            bool has_reference = std::any_of(
                params.begin(), params.end(), [this](const std::string &p) {
                    return has_reference_param(p);
                });

            if (needs_numpy || has_reference) {
                write_constructor_wrapper(cpp_type, params);
            } else {
                std::string p;
                for (size_t i = 0; i < params.size(); ++i) {
                    if (i > 0)
                        p += ", ";
                    p += normalize_type(params[i]);
                }
                line(".def(py::init<" + p + ">())");
            }
        }
    }

    // Check if a type contains a lvalue reference (but not rvalue reference)
    bool has_reference_param(const std::string &t) {
        std::string s = t;
        // Remove && (rvalue refs are fine for py::init)
        size_t pos;
        while ((pos = s.find("&&")) != std::string::npos) {
            s.erase(pos, 2);
        }
        // Now check if there's still a & (lvalue reference)
        return s.find('&') != std::string::npos;
    }

    void write_constructor_wrapper(const std::string &cpp_type,
                                   const std::vector<std::string> &params) {
        std::ostringstream w;
        w << ".def(py::init([](";
        std::vector<std::string> fwd;
        for (size_t i = 0; i < params.size(); ++i) {
            if (i > 0)
                w << ", ";
            w << get_constructor_param_type(params[i]) << " arg" << i;
            fwd.push_back(generate_input_conversion(params[i],
                                                    "arg" + std::to_string(i)));
        }
        w << ") { return std::make_shared<" << cpp_type << ">(";
        for (size_t i = 0; i < fwd.size(); ++i) {
            if (i > 0)
                w << ", ";
            w << fwd[i];
        }
        w << "); }))";
        line(w.str());
    }

    // Get parameter type for constructor wrapper lambda
    // Preserves references but converts numpy types
    std::string get_constructor_param_type(const std::string &t) {
        // Check for numpy conversion first
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "py::array_t<double>";
        if (norm.find("vector<int>") != std::string::npos)
            return "py::array_t<int>";
        
        // For reference types, preserve the reference
        if (has_reference_param(t)) {
            // Clean up internal namespace stuff but keep the &
            std::string cleaned = t;
            size_t pos;
            while ((pos = cleaned.find("std::__1::")) != std::string::npos) {
                cleaned.replace(pos, 10, "std::");
            }
            return cleaned;
        }
        
        // Default: normalize
        return norm;
    }

    void write_field(const std::string &cpp_type,
                     const std::string &field_name,
                     const rosetta::core::Registry::MetadataHolder *holder) {
        std::type_index field_type = holder->get_field_type(field_name);
        std::string type_str = rosetta::demangle(field_type.name());
        
        if (needs_numpy_conversion(type_str)) {
            std::ostringstream oss;
            oss << ".def_property(\"" << field_name << "\",\n";
            oss << "        [](const " << cpp_type << "& self) {\n";
            oss << "            return " << generate_output_conversion(type_str, "self." + field_name) << ";\n";
            oss << "        },\n";
            oss << "        [](" << cpp_type << "& self, " << get_python_param_type(type_str) << " val) {\n";
            oss << "            self." << field_name << " = " << generate_input_conversion(type_str, "val") << ";\n";
            oss << "        })";
            line(oss.str());
        } else {
            line(".def_readwrite(\"" + field_name + "\", &" + cpp_type + "::" + field_name + ")");
        }
    }

    void write_property(const std::string &cpp_type,
                        const PropertyMeta &prop,
                        const rosetta::core::Registry::MetadataHolder *holder) {
        std::string type_str = prop.get_value_type_str();
        std::string norm_type = normalize_type(type_str);
        
        if (prop.is_readonly) {
            // Read-only property
            if (needs_numpy_conversion(type_str)) {
                std::ostringstream oss;
                oss << ".def_property_readonly(\"" << prop.name << "\",\n";
                oss << "        [](const " << cpp_type << "& self) {\n";
                oss << "            return " << generate_output_conversion(type_str, 
                        "self." + (prop.getter_name.empty() ? "get" + capitalize(prop.name) + "()" : prop.getter_name + "()")) << ";\n";
                oss << "        })";
                line(oss.str());
            } else {
                // Use the getter directly if we have it
                // Since we don't store the actual method pointer, we generate a lambda
                std::ostringstream oss;
                oss << ".def_property_readonly(\"" << prop.name << "\",\n";
                oss << "        [](const " << cpp_type << "& self) {\n";
                oss << "            return self.get" << capitalize(prop.name) << "();\n";
                oss << "        })";
                line(oss.str());
            }
        } else if (prop.is_writeonly) {
            // Write-only property - pybind11 doesn't directly support this
            // We can use def_property with a throwing getter
            std::ostringstream oss;
            oss << ".def_property(\"" << prop.name << "\",\n";
            oss << "        [](const " << cpp_type << "&) -> " << norm_type << " {\n";
            oss << "            throw std::runtime_error(\"Property " << prop.name << " is write-only\");\n";
            oss << "        },\n";
            oss << "        [](" << cpp_type << "& self, " << norm_type << " val) {\n";
            oss << "            self.set" << capitalize(prop.name) << "(" << generate_input_conversion(type_str, "val") << ");\n";
            oss << "        })";
            line(oss.str());
        } else {
            // Read-write property
            if (needs_numpy_conversion(type_str)) {
                std::ostringstream oss;
                oss << ".def_property(\"" << prop.name << "\",\n";
                oss << "        [](const " << cpp_type << "& self) {\n";
                oss << "            return " << generate_output_conversion(type_str, 
                        "self.get" + capitalize(prop.name) + "()") << ";\n";
                oss << "        },\n";
                oss << "        [](" << cpp_type << "& self, " << get_python_param_type(type_str) << " val) {\n";
                oss << "            self.set" << capitalize(prop.name) << "(" << generate_input_conversion(type_str, "val") << ");\n";
                oss << "        })";
                line(oss.str());
            } else {
                std::ostringstream oss;
                oss << ".def_property(\"" << prop.name << "\",\n";
                oss << "        [](const " << cpp_type << "& self) {\n";
                oss << "            return self.get" << capitalize(prop.name) << "();\n";
                oss << "        },\n";
                oss << "        [](" << cpp_type << "& self, const " << norm_type << "& val) {\n";
                oss << "            self.set" << capitalize(prop.name) << "(val);\n";
                oss << "        })";
                line(oss.str());
            }
        }
    }

    void write_method(const std::string &cpp_type, const std::string &name,
                      const rosetta::core::Registry::MetadataHolder *holder) {
        auto info = holder->get_method_info(name);
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();
        
        // Check if we need a lambda wrapper (for numpy conversions)
        bool needs_wrapper = needs_numpy_wrapper(return_type, param_types);
        
        // Lambda methods MUST use Rosetta invocation - no member function pointer exists
        if (info.is_lambda) {
            write_lambda_method(cpp_type, name, info);
            return;
        }
        
        // Overloaded methods need wrappers for disambiguation
        if (info.is_overloaded) {
            needs_wrapper = true;
        }

        if (needs_wrapper) {
            write_wrapped_method(cpp_type, name, info);
        } else {
            // Simple direct binding - works for non-overloaded, non-lambda methods
            std::string policy = get_return_policy(return_type);
            if (!policy.empty()) {
                line(".def(\"" + name + "\", &" + cpp_type + "::" + name +
                     ", " + policy + ")");
            } else {
                line(".def(\"" + name + "\", &" + cpp_type + "::" + name + ")");
            }
        }
    }

    // Write a method that was registered via lambda_method - must invoke through Rosetta
    void write_lambda_method(const std::string &cpp_type,
                             const std::string &name,
                             const MethodMeta &info) {
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();
        
        std::ostringstream w;
        std::string self_type = info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        w << ".def(\"" << name << "\", [](" << self_type << " self";
        for (size_t i = 0; i < param_types.size(); ++i) {
            w << ", " << get_python_param_type(param_types[i]) << " arg" << i;
        }
        w << ") {\n";

        // Build argument vector for Rosetta invocation
        w << "            std::vector<rosetta::Any> args;\n";
        if (!param_types.empty()) {
            w << "            args.reserve(" << param_types.size() << ");\n";
        }
        for (size_t i = 0; i < param_types.size(); ++i) {
            std::string converted = generate_input_conversion(param_types[i], "arg" + std::to_string(i));
            w << "            args.emplace_back(" << converted << ");\n";
        }
        
        w << "            auto& meta = rosetta::Registry::instance().get<" << cpp_type << ">();\n";
        
        std::string norm_return = normalize_type(return_type);
        
        if (return_type == "void") {
            if (info.is_const) {
                w << "            meta.invoke_method(static_cast<const " << cpp_type << "&>(self), \"" << name << "\", std::move(args));\n";
            } else {
                w << "            meta.invoke_method(self, \"" << name << "\", std::move(args));\n";
            }
        } else {
            if (info.is_const) {
                w << "            auto result = meta.invoke_method(static_cast<const " << cpp_type << "&>(self), \"" << name << "\", std::move(args));\n";
            } else {
                w << "            auto result = meta.invoke_method(self, \"" << name << "\", std::move(args));\n";
            }
            w << "            return " << generate_output_conversion(return_type, "result.as<" + norm_return + ">()") << ";\n";
        }
        w << "        })";
        line(w.str());
    }

    // Write a wrapped method that calls the actual C++ member function directly
    void write_wrapped_method(const std::string &cpp_type,
                              const std::string &name,
                              const MethodMeta &info) {
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();
        
        std::ostringstream w;
        std::string self =
            info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        w << ".def(\"" << name << "\", [](" << self << " self";
        for (size_t i = 0; i < param_types.size(); ++i) {
            w << ", " << get_python_param_type(param_types[i]) << " arg" << i;
        }
        w << ") {\n";

        if (return_type == "void") {
            w << "            self." << name << "(";
            for (size_t i = 0; i < param_types.size(); ++i) {
                if (i > 0)
                    w << ", ";
                w << generate_input_conversion(param_types[i],
                                               "arg" + std::to_string(i));
            }
            w << ");\n";
        } else {
            w << "            auto result = self." << name << "(";
            for (size_t i = 0; i < param_types.size(); ++i) {
                if (i > 0)
                    w << ", ";
                w << generate_input_conversion(param_types[i],
                                               "arg" + std::to_string(i));
            }
            w << ");\n";
            w << "            return " << generate_output_conversion(return_type, "result") << ";\n";
        }
        w << "        })";
        line(w.str());
    }

    void write_utility_functions() {
        line("// Utilities");
        line("m.def(\"list_classes\", []() { return "
             "rosetta::Registry::instance().list_classes(); });");
        line("m.def(\"get_class_methods\", [](const std::string& n) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(n);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + n);");
        line("return h->get_methods();");
        dedent();
        line("});");
        line("m.def(\"get_class_fields\", [](const std::string& n) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(n);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + n);");
        line("return h->get_fields();");
        dedent();
        line("});");
        line("m.def(\"get_class_properties\", [](const std::string& n) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(n);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + n);");
        line("return h->get_properties();");
        dedent();
        line("});");
        line("m.def(\"version\", []() { return rosetta::version(); });");
    }

    // Helper methods
    std::string capitalize(const std::string& s) {
        if (s.empty()) return s;
        std::string result = s;
        result[0] = std::toupper(result[0]);
        return result;
    }

    bool needs_numpy_conversion(const std::string &t) {
        // Only convert vectors of primitives to numpy arrays
        // Vectors of registered classes are handled automatically by pybind11/stl.h
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos) return true;
        if (norm.find("vector<int>") != std::string::npos) return true;
        if (norm.find("vector<float>") != std::string::npos) return true;
        return false;
    }

    bool needs_numpy_wrapper(const std::string &ret,
                             const std::vector<std::string> &params) {
        if (needs_numpy_conversion(ret))
            return true;
        for (const auto &p : params)
            if (needs_numpy_conversion(p))
                return true;
        return false;
    }

    // Normalize type string - remove std::__1::, allocators, const, &, etc.
    std::string normalize_type(const std::string &t) {
        std::string r = t;
        
        // Remove std::__1:: (libc++ internal namespace)
        size_t pos;
        while ((pos = r.find("std::__1::")) != std::string::npos) {
            r.replace(pos, 10, "std::");
        }
        
        // Remove allocator template arguments
        // Handle std::allocator<...>
        size_t alloc_start;
        while ((alloc_start = r.find(", std::allocator<")) != std::string::npos) {
            // Find the matching >
            size_t depth = 1;
            size_t alloc_end = alloc_start + 17; // skip ", std::allocator<"
            while (alloc_end < r.size() && depth > 0) {
                if (r[alloc_end] == '<') depth++;
                else if (r[alloc_end] == '>') depth--;
                alloc_end++;
            }
            r.erase(alloc_start, alloc_end - alloc_start);
        }
        
        // Remove char_traits template arguments
        size_t traits_start;
        while ((traits_start = r.find(", std::char_traits<char>")) != std::string::npos) {
            r.erase(traits_start, 24);
        }
        
        // Convert basic_string<char> to std::string
        while ((pos = r.find("std::basic_string<char>")) != std::string::npos) {
            r.replace(pos, 23, "std::string");
        }
        // Also handle basic_string without std::
        while ((pos = r.find("basic_string<char>")) != std::string::npos) {
            r.replace(pos, 18, "std::string");
        }
        
        // Remove const and &
        for (const auto &s : {"const ", "&"}) {
            while ((pos = r.find(s)) != std::string::npos)
                r.erase(pos, strlen(s));
        }
        
        // Trim whitespace
        while (!r.empty() && r[0] == ' ')
            r.erase(0, 1);
        while (!r.empty() && r.back() == ' ')
            r.pop_back();
            
        return r;
    }

    std::string get_python_param_type(const std::string &t) {
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "py::array_t<double>";
        if (norm.find("vector<int>") != std::string::npos)
            return "py::array_t<int>";
        if (norm.find("function") != std::string::npos)
            return "std::function<Point(const Point&)>";
        return norm;
    }

    std::string generate_input_conversion(const std::string &t,
                                          const std::string &v) {
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "numpy_to_vector_double(" + v + ")";
        if (norm.find("vector<int>") != std::string::npos)
            return "numpy_to_vector_int(" + v + ")";
        return v;
    }

    std::string generate_output_conversion(const std::string &t,
                                           const std::string &v) {
        std::string norm = normalize_type(t);
        if (norm.find("vector<double>") != std::string::npos)
            return "vector_double_to_numpy(" + v + ")";
        if (norm.find("vector<int>") != std::string::npos)
            return "vector_int_to_numpy(" + v + ")";
        return v;
    }

    std::string get_return_policy(const std::string &t) {
        if (t.find("*") != std::string::npos)
            return "py::return_value_policy::reference_internal";
        if (t.find("&") != std::string::npos &&
            t.find("const") == std::string::npos)
            return "py::return_value_policy::reference_internal";
        return "";
    }
};