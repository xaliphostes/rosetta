#pragma once
#include "../CodeWriter.h"
#include <algorithm>
#include <functional>
#include <rosetta/rosetta.h>
#include <set>

// ============================================================================
// Embind C++ Code Generator - Uses Rosetta's native field/property separation
// ============================================================================

class WasmGenerator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_helpers();
        write_bindings();
    }

private:
    using ConstructorMeta = rosetta::core::Registry::MetadataHolder::ConstructorMeta;
    using MethodMeta      = rosetta::core::Registry::MetadataHolder::MethodMeta;
    using PropertyMeta    = rosetta::core::Registry::MetadataHolder::PropertyMeta;

    void write_header() {
        line("// ============================================================================");
        line("// AUTO-GENERATED EMSCRIPTEN BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// Module: " + config_.module_name);
        line("// ============================================================================");
        line();
    }

    void write_includes() {
        line("#include <emscripten/bind.h>");
        line("#include <emscripten/val.h>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();

        if (!config_.source_headers.empty()) {
            line("// Project headers");
            for (const auto &header : config_.source_headers) {
                line("#include <" + header + ">");
            }
            line();
        }

        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
            line();
        }

        line("using namespace emscripten;");
        line();
    }

    void write_helpers() {
        line("// ============================================================================");
        line("// JavaScript TypedArray <-> C++ conversion helpers");
        line("// ============================================================================");
        line();

        line("template<typename T>");
        line("std::vector<T> jsArrayToVector(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<T> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<T>();");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("template<typename T>");
        line("val vectorToJsArray(const std::vector<T>& vec) {");
        indent();
        line("val arr = val::global(\"Array\").new_();");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.call<void>(\"push\", vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("val vectorDoubleToTypedArray(const std::vector<double>& vec) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("val vectorIntToTypedArray(const std::vector<int>& vec) {");
        indent();
        line("val arr = val::global(\"Int32Array\").new_(vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("std::vector<double> typedArrayToVectorDouble(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<double> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<double>();");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("std::vector<int> typedArrayToVectorInt(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<int> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<int>();");
        line("return vec;");
        dedent();
        line("}");
        line();
    }

    void write_bindings() {
        line("// ============================================================================");
        line("// Embind Module Definition");
        line("// ============================================================================");
        line();
        line("EMSCRIPTEN_BINDINGS(" + config_.module_name + "_module) {");
        indent();
        line();

        auto &registry    = rosetta::Registry::instance();
        auto  class_names = registry.list_classes();
        auto  sorted      = topological_sort(class_names, registry);

        // First, register all classes
        for (const auto &name : sorted) {
            auto *holder = registry.get_by_name(name);
            if (holder) {
                write_class_binding(name, holder);
            }
        }

        // Register vector types for registered classes
        line("// Register vector types for proper array conversion");
        for (const auto &name : sorted) {
            auto *holder = registry.get_by_name(name);
            if (holder && !config_.should_skip_class(name)) {
                std::string cpp_type = holder->get_cpp_type_name();
                line("register_vector<" + cpp_type + ">(\"Vector" + name + "\");");
            }
        }
        line();

        write_utility_functions();

        dedent();
        line("}");
    }

    std::vector<std::string> topological_sort(const std::vector<std::string> &names,
                                              rosetta::Registry              &registry) {
        std::vector<std::string> sorted;
        std::set<std::string>    visited;
        std::set<std::string>    name_set(names.begin(), names.end());

        std::function<void(const std::string &)> visit = [&](const std::string &n) {
            if (visited.count(n))
                return;
            visited.insert(n);
            auto *h = registry.get_by_name(n);
            if (h) {
                auto base = h->get_base_class();
                if (!base.empty()) {
                    size_t      pos = base.rfind("::");
                    std::string base_name =
                        (pos != std::string::npos) ? base.substr(pos + 2) : base;
                    if (name_set.count(base_name))
                        visit(base_name);
                }
            }
            sorted.push_back(n);
        };

        for (const auto &n : names)
            visit(n);
        return sorted;
    }

    void write_class_binding(const std::string                             &name,
                             const rosetta::core::Registry::MetadataHolder *holder) {
        if (config_.should_skip_class(name)) {
            line("// Skipped: " + name);
            return;
        }

        line("// --- " + name + " ---");
        std::string cpp_type = holder->get_cpp_type_name();
        auto        base     = holder->get_base_class();

        if (!base.empty()) {
            line("class_<" + cpp_type + ", base<" + base + ">>(\"" + name + "\")");
        } else {
            line("class_<" + cpp_type + ">(\"" + name + "\")");
        }
        indent();

        line(".smart_ptr<std::shared_ptr<" + cpp_type + ">>(\"" + name + "Ptr\")");

        // Constructors
        for (const auto &ctor : holder->get_constructors()) {
            write_constructor(cpp_type, ctor);
        }

        // Fields (actual C++ member fields)
        for (const auto &field : holder->get_fields()) {
            if (!config_.should_skip_method(name, field)) {
                write_field(cpp_type, field, holder);
            }
        }

        // Properties (virtual fields via getter/setter) - using new Rosetta API!
        for (const auto &prop_name : holder->get_properties()) {
            if (!config_.should_skip_method(name, prop_name)) {
                auto prop_info = holder->get_property_info(prop_name);
                write_property(cpp_type, prop_info, holder);
            }
        }

        // Methods
        for (const auto &m : holder->get_methods()) {
            if (!config_.should_skip_method(name, m)) {
                write_method(cpp_type, m, holder);
            }
        }

        line(";");
        dedent();
        line();
    }

    void write_constructor(const std::string &cpp_type, const ConstructorMeta &ctor) {
        auto params = ctor.get_param_types();
        if (params.empty()) {
            line(".constructor<>()");
        } else {
            bool needs_wrapper =
                std::any_of(params.begin(), params.end(),
                            [this](const std::string &p) { return needs_conversion(p); });

            if (needs_wrapper) {
                write_constructor_wrapper(cpp_type, params);
            } else {
                std::string p;
                for (size_t i = 0; i < params.size(); ++i) {
                    if (i > 0)
                        p += ", ";
                    p += normalize_type(params[i]);
                }
                line(".constructor<" + p + ">()");
            }
        }
    }

    void write_constructor_wrapper(const std::string              &cpp_type,
                                   const std::vector<std::string> &params) {
        std::ostringstream oss;
        oss << ".class_function(\"create\", +[](";

        std::vector<std::string> args;
        for (size_t i = 0; i < params.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << get_js_param_type(params[i]) << " arg" << i;
            args.push_back(generate_input_conversion(params[i], "arg" + std::to_string(i)));
        }
        oss << ") {\n";
        oss << "            return " << cpp_type << "(" << join(args, ", ") << ");\n";
        oss << "        })";
        line(oss.str());
    }

    void write_field(const std::string &cpp_type, const std::string &field_name,
                     const rosetta::core::Registry::MetadataHolder *holder) {
        std::type_index field_type = holder->get_field_type(field_name);
        std::string     type_str   = rosetta::demangle(field_type.name());

        if (needs_conversion(type_str)) {
            std::ostringstream oss;
            oss << ".property(\"" << field_name << "\",\n";
            oss << "        +[](const " << cpp_type << "& self) {\n";
            oss << "            return "
                << generate_output_conversion(type_str, "self." + field_name) << ";\n";
            oss << "        },\n";
            oss << "        +[](" << cpp_type << "& self, " << get_js_param_type(type_str)
                << " val) {\n";
            oss << "            self." << field_name << " = "
                << generate_input_conversion(type_str, "val") << ";\n";
            oss << "        })";
            line(oss.str());
        } else {
            line(".property(\"" + field_name + "\", &" + cpp_type + "::" + field_name + ")");
        }
    }

    void write_property(const std::string &cpp_type, const PropertyMeta &prop,
                        const rosetta::core::Registry::MetadataHolder *holder) {
        std::string type_str = prop.get_value_type_str();

        if (prop.is_readonly) {
            // Read-only property
            std::ostringstream oss;
            oss << ".property(\"" << prop.name << "\",\n";
            oss << "        +[](const " << cpp_type << "& self) {\n";
            oss << "            return "
                << generate_output_conversion(type_str, "self.get" + capitalize(prop.name) + "()")
                << ";\n";
            oss << "        })";
            line(oss.str());
        } else {
            // Read-write property
            std::ostringstream oss;
            oss << ".property(\"" << prop.name << "\",\n";
            oss << "        +[](const " << cpp_type << "& self) {\n";
            oss << "            return "
                << generate_output_conversion(type_str, "self.get" + capitalize(prop.name) + "()")
                << ";\n";
            oss << "        },\n";
            oss << "        +[](" << cpp_type << "& self, " << get_js_param_type(type_str)
                << " val) {\n";
            oss << "            self.set" << capitalize(prop.name) << "("
                << generate_input_conversion(type_str, "val") << ");\n";
            oss << "        })";
            line(oss.str());
        }
    }

    void write_method(const std::string &cpp_type, const std::string &method_name,
                      const rosetta::core::Registry::MetadataHolder *holder) {
        auto info        = holder->get_method_info(method_name);
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        // Lambda methods MUST use Rosetta invocation - no member function pointer exists
        if (info.is_lambda) {
            write_lambda_method(cpp_type, method_name, info);
            return;
        }

        bool needs_wrapper =
            needs_conversion(return_type) ||
            std::any_of(param_types.begin(), param_types.end(),
                        [this](const std::string &p) { return needs_conversion(p); });

        if (needs_wrapper) {
            write_method_wrapper(cpp_type, method_name, info);
        } else {
            line(".function(\"" + method_name + "\", &" + cpp_type + "::" + method_name + ")");
        }
    }

    // Write a method that was registered via lambda_method - must invoke through Rosetta
    void write_lambda_method(const std::string &cpp_type, const std::string &method_name,
                             const MethodMeta &info) {
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        std::ostringstream oss;
        std::string        self_type = info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        oss << ".function(\"" << method_name << "\", +[](" << self_type << " self";

        for (size_t i = 0; i < param_types.size(); ++i) {
            oss << ", " << get_js_param_type(param_types[i]) << " arg" << i;
        }
        oss << ") {\n";

        // Build argument vector for Rosetta invocation
        oss << "            std::vector<rosetta::Any> args;\n";
        if (!param_types.empty()) {
            oss << "            args.reserve(" << param_types.size() << ");\n";
        }
        for (size_t i = 0; i < param_types.size(); ++i) {
            std::string converted =
                generate_input_conversion(param_types[i], "arg" + std::to_string(i));
            oss << "            args.emplace_back(" << converted << ");\n";
        }

        oss << "            auto& meta = rosetta::Registry::instance().get<" << cpp_type
            << ">();\n";

        std::string norm_return = normalize_type(return_type);

        if (return_type == "void") {
            if (info.is_const) {
                oss << "            meta.invoke_method(static_cast<const " << cpp_type
                    << "&>(self), \"" << method_name << "\", std::move(args));\n";
            } else {
                oss << "            meta.invoke_method(self, \"" << method_name
                    << "\", std::move(args));\n";
            }
        } else {
            if (info.is_const) {
                oss << "            auto result = meta.invoke_method(static_cast<const " << cpp_type
                    << "&>(self), \"" << method_name << "\", std::move(args));\n";
            } else {
                oss << "            auto result = meta.invoke_method(self, \"" << method_name
                    << "\", std::move(args));\n";
            }
            oss << "            return "
                << generate_output_conversion(return_type, "result.as<" + norm_return + ">()")
                << ";\n";
        }
        oss << "        })";
        line(oss.str());
    }

    void write_method_wrapper(const std::string &cpp_type, const std::string &method_name,
                              const MethodMeta &info) {
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        std::ostringstream oss;
        std::string        self_type = info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        oss << ".function(\"" << method_name << "\", +[](" << self_type << " self";

        std::vector<std::string> args;
        for (size_t i = 0; i < param_types.size(); ++i) {
            oss << ", " << get_js_param_type(param_types[i]) << " arg" << i;
            args.push_back(generate_input_conversion(param_types[i], "arg" + std::to_string(i)));
        }
        oss << ") {\n";

        if (return_type == "void") {
            oss << "            self." << method_name << "(" << join(args, ", ") << ");\n";
        } else {
            oss << "            auto result = self." << method_name << "(" << join(args, ", ")
                << ");\n";
            oss << "            return " << generate_output_conversion(return_type, "result")
                << ";\n";
        }
        oss << "        })";
        line(oss.str());
    }

    void write_utility_functions() {
        line("// Utility functions for introspection");
        line("function(\"listClasses\", +[]() {");
        indent();
        line("return rosetta::Registry::instance().list_classes();");
        dedent();
        line("});");
        line();

        line("function(\"getClassMethods\", +[](const std::string& name) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + name);");
        line("return h->get_methods();");
        dedent();
        line("});");
        line();

        line("function(\"getClassFields\", +[](const std::string& name) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + name);");
        line("return h->get_fields();");
        dedent();
        line("});");
        line();

        line("function(\"getClassProperties\", +[](const std::string& name) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + name);");
        line("return h->get_properties();");
        dedent();
        line("});");
        line();

        line("function(\"version\", +[]() {");
        indent();
        line("return rosetta::version();");
        dedent();
        line("});");
    }

    // Helper methods
    std::string capitalize(const std::string &s) {
        if (s.empty())
            return s;
        std::string result = s;
        result[0]          = std::toupper(result[0]);
        return result;
    }

    // Normalize type string - remove std::__1::, allocators, const, &, etc.
    std::string normalize_type(const std::string &t) {
        std::string r = t;

        // Remove std::__1:: (libc++ internal namespace)
        size_t pos;
        while ((pos = r.find("std::__1::")) != std::string::npos) {
            r.replace(pos, 10, "std::");
        }

        // Remove allocator template arguments
        // Handle nested allocators like std::allocator<Surface>
        size_t alloc_start;
        while ((alloc_start = r.find(", std::allocator<")) != std::string::npos) {
            // Find the matching >
            size_t depth     = 1;
            size_t alloc_end = alloc_start + 17; // skip ", std::allocator<"
            while (alloc_end < r.size() && depth > 0) {
                if (r[alloc_end] == '<')
                    depth++;
                else if (r[alloc_end] == '>')
                    depth--;
                alloc_end++;
            }
            r.erase(alloc_start, alloc_end - alloc_start);
        }

        // Remove const and &
        while ((pos = r.find("const ")) != std::string::npos)
            r.erase(pos, 6);
        while ((pos = r.find("&")) != std::string::npos)
            r.erase(pos, 1);

        // Trim whitespace
        while (!r.empty() && r[0] == ' ')
            r.erase(0, 1);
        while (!r.empty() && r.back() == ' ')
            r.pop_back();

        return r;
    }

    // Check if type is a vector (handles various forms)
    bool is_vector_type(const std::string &type) {
        std::string norm = normalize_type(type);
        return norm.find("vector<") != std::string::npos ||
               norm.find("std::vector<") != std::string::npos;
    }

    // Extract element type from vector, handling allocators properly
    std::string extract_vector_element_type(const std::string &type) {
        std::string norm = normalize_type(type);

        size_t start = norm.find("vector<");
        if (start == std::string::npos)
            return "";
        start += 7; // skip "vector<"

        // Find matching > accounting for nested templates
        int    depth = 1;
        size_t end   = start;
        while (end < norm.size() && depth > 0) {
            if (norm[end] == '<')
                depth++;
            else if (norm[end] == '>')
                depth--;
            if (depth > 0)
                end++;
        }

        std::string elem = norm.substr(start, end - start);

        // Trim whitespace
        while (!elem.empty() && elem[0] == ' ')
            elem.erase(0, 1);
        while (!elem.empty() && elem.back() == ' ')
            elem.pop_back();

        return elem;
    }

    // Check if a type is a registered class
    bool is_registered_class(const std::string &type_name) {
        auto       &registry = rosetta::Registry::instance();
        std::string norm     = normalize_type(type_name);

        // Try the type name directly
        if (registry.get_by_name(norm) != nullptr)
            return true;

        // Try stripping namespace
        size_t pos = norm.rfind("::");
        if (pos != std::string::npos) {
            std::string short_name = norm.substr(pos + 2);
            if (registry.get_by_name(short_name) != nullptr)
                return true;
        }

        // Also try the original type name
        if (registry.get_by_name(type_name) != nullptr)
            return true;

        return false;
    }

    bool needs_conversion(const std::string &type) {
        if (type.find("vector<") != std::string::npos)
            return true;
        if (type.find("function") != std::string::npos)
            return true;

        // Check if it's a registered class type that needs wrapping
        std::string elem = extract_vector_element_type(type);
        if (!elem.empty() && is_registered_class(elem))
            return true;

        return false;
    }

    std::string get_js_param_type(const std::string &type) {
        if (is_vector_type(type))
            return "val";
        if (type.find("function") != std::string::npos)
            return "val";

        // For registered classes that need conversion
        std::string norm = normalize_type(type);
        if (is_registered_class(norm))
            return "val";

        return norm;
    }

    // Check if type is a std::function
    bool is_function_type(const std::string &type) {
        std::string norm = normalize_type(type);
        return norm.find("function<") != std::string::npos ||
               norm.find("std::function<") != std::string::npos;
    }

    // Extract function signature from std::function<ReturnType(ParamTypes...)>
    struct FunctionSignature {
        std::string              return_type;
        std::vector<std::string> param_types;
    };

    FunctionSignature extract_function_signature(const std::string &type) {
        FunctionSignature sig;
        std::string       norm = normalize_type(type);

        // Find "function<"
        size_t start = norm.find("function<");
        if (start == std::string::npos)
            return sig;
        start += 9; // skip "function<"

        // Find the return type (everything before the '(')
        size_t paren_start = norm.find('(', start);
        if (paren_start == std::string::npos)
            return sig;

        sig.return_type = norm.substr(start, paren_start - start);
        // Trim whitespace
        while (!sig.return_type.empty() && sig.return_type[0] == ' ')
            sig.return_type.erase(0, 1);
        while (!sig.return_type.empty() && sig.return_type.back() == ' ')
            sig.return_type.pop_back();

        // Find the closing paren
        size_t paren_end = norm.find(')', paren_start);
        if (paren_end == std::string::npos)
            return sig;

        // Extract parameter types
        std::string params_str = norm.substr(paren_start + 1, paren_end - paren_start - 1);

        // Split by comma, accounting for nested templates
        if (!params_str.empty()) {
            int    depth      = 0;
            size_t last_start = 0;
            for (size_t i = 0; i <= params_str.size(); ++i) {
                if (i == params_str.size() || (params_str[i] == ',' && depth == 0)) {
                    std::string param = params_str.substr(last_start, i - last_start);
                    // Trim whitespace
                    while (!param.empty() && param[0] == ' ')
                        param.erase(0, 1);
                    while (!param.empty() && param.back() == ' ')
                        param.pop_back();
                    if (!param.empty()) {
                        sig.param_types.push_back(param);
                    }
                    last_start = i + 1;
                } else if (params_str[i] == '<') {
                    depth++;
                } else if (params_str[i] == '>') {
                    depth--;
                }
            }
        }

        return sig;
    }

    std::string generate_input_conversion(const std::string &type, const std::string &var) {
        std::string norm = normalize_type(type);

        // Handle std::function types
        if (is_function_type(norm)) {
            return generate_function_conversion(type, var);
        }

        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "typedArrayToVectorDouble(" + var + ")";
            }
            if (elem == "int") {
                return "typedArrayToVectorInt(" + var + ")";
            }
            // For vectors of registered classes
            if (is_registered_class(elem)) {
                return "jsArrayToVector<" + elem + ">(" + var + ")";
            }
            // Generic case
            return "jsArrayToVector<" + elem + ">(" + var + ")";
        }

        return var;
    }

    // Generate conversion code for std::function from JavaScript function
    std::string generate_function_conversion(const std::string &type, const std::string &var) {
        auto sig = extract_function_signature(type);

        if (sig.return_type.empty()) {
            // Fallback if parsing failed
            return var;
        }

        std::ostringstream oss;

        // Create a lambda that wraps the JavaScript function
        oss << "[" << var << "](";

        // Generate parameter list
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << sig.param_types[i] << " p" << i;
        }
        oss << ") -> " << sig.return_type << " {\n";
        oss << "                return " << var << "(";

        // Pass parameters to JS function
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << "p" << i;
        }
        oss << ").template as<" << sig.return_type << ">();\n";
        oss << "            }";

        return oss.str();
    }

    std::string generate_output_conversion(const std::string &type, const std::string &var) {
        std::string norm = normalize_type(type);

        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "vectorDoubleToTypedArray(" + var + ")";
            }
            if (elem == "int") {
                return "vectorIntToTypedArray(" + var + ")";
            }
            // For vectors of registered classes - use template version
            return "vectorToJsArray<" + elem + ">(" + var + ")";
        }

        return var;
    }
};