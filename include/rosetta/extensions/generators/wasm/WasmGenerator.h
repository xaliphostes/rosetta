#pragma once
#include "../common/CodeWriter.h"
#include <algorithm>
#include <functional>
#include <rosetta/rosetta.h>
#include <set>

// ============================================================================
// Embind C++ Code Generator - Uses Rosetta's native field/property separation
// ============================================================================

class WasmGenerator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_helpers();
        write_bindings();
    }

private:
    using ConstructorMeta = rosetta::core::Registry::MetadataHolder::ConstructorMeta;
    using MethodMeta      = rosetta::core::Registry::MetadataHolder::MethodMeta;
    using PropertyMeta    = rosetta::core::Registry::MetadataHolder::PropertyMeta;

    void write_header() {
        line("// ============================================================================");
        line("// AUTO-GENERATED EMSCRIPTEN BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// Module: " + config_.module_name);
        line("// ============================================================================");
        line();
    }

    void write_includes() {
        line("#include <emscripten/bind.h>");
        line("#include <emscripten/val.h>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();

        if (!config_.source_headers.empty()) {
            line("// Project headers");
            for (const auto &header : config_.source_headers) {
                line("#include <" + header + ">");
            }
            line();
        }

        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
            line();
        }

        line("using namespace emscripten;");
        line();
    }

    void write_helpers() {
        line("// ============================================================================");
        line("// JavaScript TypedArray <-> C++ conversion helpers");
        line("// ============================================================================");
        line();

        line("template<typename T>");
        line("std::vector<T> jsArrayToVector(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<T> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<T>();");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("template<typename T>");
        line("val vectorToJsArray(const std::vector<T>& vec) {");
        indent();
        line("val arr = val::global(\"Array\").new_();");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.call<void>(\"push\", vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("val vectorDoubleToTypedArray(const std::vector<double>& vec) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("val vectorIntToTypedArray(const std::vector<int>& vec) {");
        indent();
        line("val arr = val::global(\"Int32Array\").new_(vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("std::vector<double> typedArrayToVectorDouble(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<double> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<double>();");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("std::vector<int> typedArrayToVectorInt(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<int> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<int>();");
        line("return vec;");
        dedent();
        line("}");
        line();
    }

    void write_bindings() {
        line("// ============================================================================");
        line("// Embind Module Definition");
        line("// ============================================================================");
        line();
        line("EMSCRIPTEN_BINDINGS(" + config_.module_name + "_module) {");
        indent();
        line();
        
        // Call Rosetta registration function first!
        // This is critical - without it, lambda_method invocations will fail
        if (!config_.registration_function.empty()) {
            line("// Initialize Rosetta registry (required for lambda_method invocations)");
            line(config_.get_registration_call() + ";");
            line();
        }

        auto &registry    = rosetta::Registry::instance();
        auto  class_names = registry.list_classes();
        auto  sorted      = topological_sort(class_names, registry);

        // First, register all classes
        for (const auto &name : sorted) {
            auto *holder = registry.get_by_name(name);
            if (holder) {
                write_class_binding(name, holder);
            }
        }

        // Register vector types for registered classes
        // Skip abstract classes and classes without default constructors
        line("// Register vector types for proper array conversion");
        for (const auto &name : sorted) {
            auto *holder = registry.get_by_name(name);
            if (holder && !config_.should_skip_class(name)) {
                // Skip abstract classes - can't instantiate them
                if (holder->get_inheritance().is_abstract) {
                    line("// Skipped Vector" + config_.binding_name(name) + " - abstract class");
                    continue;
                }
                
                // Skip classes that shouldn't be in vectors (configurable)
                if (should_skip_vector_registration(name)) {
                    line("// Skipped Vector" + config_.binding_name(name) + " - not vectorizable");
                    continue;
                }
                
                std::string cpp_type = holder->get_cpp_type_name();
                std::string js_name = config_.binding_name(name);
                line("register_vector<" + cpp_type + ">(\"Vector" + js_name + "\");");
            }
        }
        line();

        write_utility_functions();

        dedent();
        line("}");
    }
    
    // Check if a class should be skipped for vector registration
    // A class can be in a vector if it's:
    // - Not abstract
    // - Has a default or copy constructor
    // - Is copyable/movable (detected via heuristics)
    bool should_skip_vector_registration(const std::string &name) const {
        auto &registry = rosetta::Registry::instance();
        auto *holder = registry.get_by_name(name);
        
        if (!holder) return true;
        
        // Abstract classes can't be instantiated
        if (holder->get_inheritance().is_abstract) return true;
        
        // Check config for explicitly skipped vector classes
        // Convention: add "Vector::ClassName" to skip_classes
        if (config_.skip_classes.count("Vector::" + name) > 0) return true;
        if (config_.skip_classes.count("Vector::" + config_.binding_name(name)) > 0) return true;
        
        auto ctors = holder->get_constructors();
        
        // No constructors registered - can't be put in vector
        if (ctors.empty()) return true;
        
        // Check if class has a default constructor (required for std::vector resize)
        bool has_default_ctor = false;
        bool has_reference_ctor = false;
        
        for (const auto &ctor : ctors) {
            auto params = ctor.get_param_types();
            
            if (params.empty()) {
                has_default_ctor = true;
            }
            
            // Check if any constructor takes a non-const reference
            // This is a strong hint the class stores the reference as a member
            // making it non-copy-assignable (like Postprocess with const Model& model_)
            for (const auto &param : params) {
                // Check for reference types (but not const references to primitives)
                if (is_nonconst_reference_type(param)) {
                    // Non-const reference parameter - likely stored as member
                    has_reference_ctor = true;
                }
                // Also check for const references to complex types (like const Model&)
                if (is_const_reference_to_class(param)) {
                    has_reference_ctor = true;
                }
            }
        }
        
        // If class takes a reference in constructor, it likely stores it
        // making it non-copyable (reference members delete copy assignment)
        if (has_reference_ctor) return true;
        
        // Must have default constructor for vector operations
        if (!has_default_ctor) return true;
        
        return false;
    }
    
    // Check if type is a const reference to a class (not a primitive)
    // e.g., "const Model&", "const arch::Model &" -> true
    // e.g., "const int&", "const double&" -> false
    bool is_const_reference_to_class(const std::string &type) const {
        std::string t = type;
        
        // Must have const
        if (t.find("const") == std::string::npos) return false;
        
        // Must have &
        bool has_ref = false;
        int depth = 0;
        for (char c : t) {
            if (c == '<') depth++;
            else if (c == '>') depth--;
            else if (c == '&' && depth == 0) has_ref = true;
        }
        if (!has_ref) return false;
        
        // Check if it's NOT a primitive type
        static const std::set<std::string> primitives = {
            "int", "float", "double", "bool", "char", 
            "long", "short", "unsigned", "size_t",
            "int8_t", "int16_t", "int32_t", "int64_t",
            "uint8_t", "uint16_t", "uint32_t", "uint64_t"
        };
        
        // Extract the base type (remove const, &, whitespace)
        std::string base = t;
        size_t pos;
        while ((pos = base.find("const ")) != std::string::npos) base.erase(pos, 6);
        while ((pos = base.find("&")) != std::string::npos) base.erase(pos, 1);
        while (!base.empty() && base[0] == ' ') base.erase(0, 1);
        while (!base.empty() && base.back() == ' ') base.pop_back();
        
        // Check if base type is a primitive
        for (const auto &prim : primitives) {
            if (base == prim) return false;
        }
        
        // Also check std::string - it's copyable
        if (base.find("string") != std::string::npos) return false;
        
        // It's a const reference to a class type
        return true;
    }

    std::vector<std::string> topological_sort(const std::vector<std::string> &names,
                                              rosetta::Registry              &registry) {
        std::vector<std::string> sorted;
        std::set<std::string>    visited;
        std::set<std::string>    name_set(names.begin(), names.end());

        std::function<void(const std::string &)> visit = [&](const std::string &n) {
            if (visited.count(n))
                return;
            visited.insert(n);
            auto *h = registry.get_by_name(n);
            if (h) {
                auto base = h->get_base_class();
                if (!base.empty()) {
                    // Try to find the base class in the registry
                    // It might be registered with full name (arch::Base) or short name (Base)
                    if (name_set.count(base)) {
                        visit(base);
                    } else {
                        // Try stripped name
                        size_t pos = base.rfind("::");
                        std::string base_short = (pos != std::string::npos) ? base.substr(pos + 2) : base;
                        if (name_set.count(base_short)) {
                            visit(base_short);
                        }
                    }
                }
            }
            sorted.push_back(n);
        };

        for (const auto &n : names)
            visit(n);
        return sorted;
    }

    void write_class_binding(const std::string                             &name,
                             const rosetta::core::Registry::MetadataHolder *holder) {
        if (config_.should_skip_class(name)) {
            line("// Skipped: " + name);
            return;
        }

        // Get clean JavaScript name (strips namespace by default)
        std::string js_name = config_.binding_name(name);
        
        line("// --- " + name + " ---");
        std::string cpp_type = holder->get_cpp_type_name();
        auto        base     = holder->get_base_class();

        if (!base.empty()) {
            line("class_<" + cpp_type + ", base<" + base + ">>(\"" + js_name + "\")");
        } else {
            line("class_<" + cpp_type + ">(\"" + js_name + "\")");
        }
        indent();

        line(".smart_ptr<std::shared_ptr<" + cpp_type + ">>(\"" + js_name + "Ptr\")");

        // Constructors
        for (const auto &ctor : holder->get_constructors()) {
            write_constructor(cpp_type, ctor);
        }

        // Fields (actual C++ member fields)
        for (const auto &field : holder->get_fields()) {
            if (!config_.should_skip_method(name, field)) {
                write_field(cpp_type, field, holder);
            }
        }

        // Properties (virtual fields via getter/setter) - using new Rosetta API!
        for (const auto &prop_name : holder->get_properties()) {
            if (!config_.should_skip_method(name, prop_name)) {
                auto prop_info = holder->get_property_info(prop_name);
                write_property(cpp_type, prop_info, holder);
            }
        }

        // Methods
        for (const auto &m : holder->get_methods()) {
            if (!config_.should_skip_method(name, m)) {
                write_method(cpp_type, m, holder);
            }
        }

        line(";");
        dedent();
        line();
    }

    void write_constructor(const std::string &cpp_type, const ConstructorMeta &ctor) {
        auto params = ctor.get_param_types();
        if (params.empty()) {
            line(".constructor<>()");
        } else {
            // Check if any parameter needs a wrapper
            // NOTE: Plain references (Model&) work fine with embind's .constructor<>
            // Only need wrapper for:
            // - Pointers (Model* needs &arg conversion)
            // - Vectors (need TypedArray conversion)
            // - std::function (need JS function wrapping)
            bool needs_wrapper =
                std::any_of(params.begin(), params.end(),
                            [this](const std::string &p) { 
                                return needs_conversion(p) || is_pointer_type(p); 
                            });

            if (needs_wrapper) {
                write_constructor_wrapper(cpp_type, params);
            } else {
                // Use direct constructor - embind handles references fine
                std::string p;
                for (size_t i = 0; i < params.size(); ++i) {
                    if (i > 0)
                        p += ", ";
                    // Keep the type as-is (including & for references)
                    p += params[i];
                }
                line(".constructor<" + p + ">()");
            }
        }
    }

    void write_constructor_wrapper(const std::string              &cpp_type,
                                   const std::vector<std::string> &params) {
        // Use an inline lambda with embind's constructor() overload
        // The lambda returns by value, embind handles construction
        
        std::ostringstream oss;
        oss << ".constructor(+[](";

        std::vector<std::string> args;
        for (size_t i = 0; i < params.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << get_js_param_type(params[i]) << " arg" << i;
            args.push_back(generate_input_conversion(params[i], "arg" + std::to_string(i)));
        }
        oss << ") {\n";
        oss << "            return " << cpp_type << "(" << join(args, ", ") << ");\n";
        oss << "        })";
        line(oss.str());
    }

    void write_field(const std::string &cpp_type, const std::string &field_name,
                     const rosetta::core::Registry::MetadataHolder *holder) {
        std::type_index field_type = holder->get_field_type(field_name);
        std::string     type_str   = rosetta::demangle(field_type.name());

        if (needs_conversion(type_str)) {
            std::ostringstream oss;
            oss << ".property(\"" << field_name << "\",\n";
            oss << "        +[](const " << cpp_type << "& self) {\n";
            oss << "            return "
                << generate_output_conversion(type_str, "self." + field_name) << ";\n";
            oss << "        },\n";
            oss << "        +[](" << cpp_type << "& self, " << get_js_param_type(type_str)
                << " val) {\n";
            oss << "            self." << field_name << " = "
                << generate_input_conversion(type_str, "val") << ";\n";
            oss << "        })";
            line(oss.str());
        } else {
            line(".property(\"" + field_name + "\", &" + cpp_type + "::" + field_name + ")");
        }
    }

    void write_property(const std::string &cpp_type, const PropertyMeta &prop,
                        const rosetta::core::Registry::MetadataHolder *holder) {
        std::string type_str = prop.get_value_type_str();

        if (prop.is_readonly) {
            // Read-only property
            std::ostringstream oss;
            oss << ".property(\"" << prop.name << "\",\n";
            oss << "        +[](const " << cpp_type << "& self) {\n";
            oss << "            return "
                << generate_output_conversion(type_str, "self.get" + capitalize(prop.name) + "()")
                << ";\n";
            oss << "        })";
            line(oss.str());
        } else {
            // Read-write property
            std::ostringstream oss;
            oss << ".property(\"" << prop.name << "\",\n";
            oss << "        +[](const " << cpp_type << "& self) {\n";
            oss << "            return "
                << generate_output_conversion(type_str, "self.get" + capitalize(prop.name) + "()")
                << ";\n";
            oss << "        },\n";
            oss << "        +[](" << cpp_type << "& self, " << get_js_param_type(type_str)
                << " val) {\n";
            oss << "            self.set" << capitalize(prop.name) << "("
                << generate_input_conversion(type_str, "val") << ");\n";
            oss << "        })";
            line(oss.str());
        }
    }

    void write_method(const std::string &cpp_type, const std::string &method_name,
                      const rosetta::core::Registry::MetadataHolder *holder) {
        auto info        = holder->get_method_info(method_name);
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        // Lambda methods MUST use Rosetta invocation - no member function pointer exists
        if (info.is_lambda) {
            write_lambda_method(cpp_type, method_name, info);
            return;
        }

        // Use lambda wrapper when:
        // 1. Method is overloaded (embind can't disambiguate)
        // 2. Return type needs conversion (vectors -> TypedArray)
        // 3. Parameters need conversion (vectors, pointers, std::function)
        // NOTE: Plain references (Model&) work fine with embind - no wrapper needed
        bool needs_wrapper = info.is_overloaded ||
            needs_conversion(return_type) ||
            std::any_of(param_types.begin(), param_types.end(),
                        [this](const std::string &p) { 
                            return needs_conversion(p) || is_pointer_type(p); 
                        });

        if (needs_wrapper) {
            write_method_wrapper(cpp_type, method_name, info);
        } else {
            line(".function(\"" + method_name + "\", &" + cpp_type + "::" + method_name + ")");
        }
    }

    // Write a method that was registered via lambda_method - must invoke through Rosetta
    void write_lambda_method(const std::string &cpp_type, const std::string &method_name,
                             const MethodMeta &info) {
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        std::ostringstream oss;
        std::string        self_type = info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        oss << ".function(\"" << method_name << "\", +[](" << self_type << " self";

        for (size_t i = 0; i < param_types.size(); ++i) {
            oss << ", " << get_js_param_type(param_types[i]) << " arg" << i;
        }
        oss << ") {\n";

        // Build argument vector for Rosetta invocation
        oss << "            std::vector<rosetta::Any> args;\n";
        if (!param_types.empty()) {
            oss << "            args.reserve(" << param_types.size() << ");\n";
        }
        for (size_t i = 0; i < param_types.size(); ++i) {
            std::string converted =
                generate_input_conversion(param_types[i], "arg" + std::to_string(i));
            oss << "            args.emplace_back(" << converted << ");\n";
        }

        oss << "            auto& meta = rosetta::Registry::instance().get<" << cpp_type
            << ">();\n";

        std::string norm_return = normalize_type(return_type);

        if (return_type == "void") {
            if (info.is_const) {
                oss << "            meta.invoke_method(static_cast<const " << cpp_type
                    << "&>(self), \"" << method_name << "\", std::move(args));\n";
            } else {
                oss << "            meta.invoke_method(self, \"" << method_name
                    << "\", std::move(args));\n";
            }
        } else {
            if (info.is_const) {
                oss << "            auto result = meta.invoke_method(static_cast<const " << cpp_type
                    << "&>(self), \"" << method_name << "\", std::move(args));\n";
            } else {
                oss << "            auto result = meta.invoke_method(self, \"" << method_name
                    << "\", std::move(args));\n";
            }
            oss << "            return "
                << generate_output_conversion(return_type, "result.as<" + norm_return + ">()")
                << ";\n";
        }
        oss << "        })";
        line(oss.str());
    }

    void write_method_wrapper(const std::string &cpp_type, const std::string &method_name,
                              const MethodMeta &info) {
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        std::ostringstream oss;
        std::string        self_type = info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        oss << ".function(\"" << method_name << "\", +[](" << self_type << " self";

        std::vector<std::string> args;
        for (size_t i = 0; i < param_types.size(); ++i) {
            oss << ", " << get_js_param_type(param_types[i]) << " arg" << i;
            args.push_back(generate_input_conversion(param_types[i], "arg" + std::to_string(i)));
        }
        oss << ") {\n";

        if (return_type == "void") {
            oss << "            self." << method_name << "(" << join(args, ", ") << ");\n";
        } else {
            oss << "            auto result = self." << method_name << "(" << join(args, ", ")
                << ");\n";
            oss << "            return " << generate_output_conversion(return_type, "result")
                << ";\n";
        }
        oss << "        })";
        line(oss.str());
    }

    void write_utility_functions() {
        line("// Utility functions for introspection");
        line("function(\"listClasses\", +[]() {");
        indent();
        line("return rosetta::Registry::instance().list_classes();");
        dedent();
        line("});");
        line();

        line("function(\"getClassMethods\", +[](const std::string& name) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + name);");
        line("return h->get_methods();");
        dedent();
        line("});");
        line();

        line("function(\"getClassFields\", +[](const std::string& name) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + name);");
        line("return h->get_fields();");
        dedent();
        line("});");
        line();

        line("function(\"getClassProperties\", +[](const std::string& name) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + name);");
        line("return h->get_properties();");
        dedent();
        line("});");
        line();

        line("function(\"version\", +[]() {");
        indent();
        line("return rosetta::version();");
        dedent();
        line("});");
    }

    // Helper methods
    std::string capitalize(const std::string &s) {
        if (s.empty())
            return s;
        std::string result = s;
        result[0]          = std::toupper(result[0]);
        return result;
    }

    // ========================================================================
    // NEW: Pointer type detection and handling
    // ========================================================================
    
    // Check if a type is a pointer type (e.g., "Model *", "Model*", "arch::Model *")
    bool is_pointer_type(const std::string &type) const {
        std::string t = type;
        // Remove const
        size_t pos;
        while ((pos = t.find("const ")) != std::string::npos)
            t.erase(pos, 6);
        // Trim whitespace
        while (!t.empty() && t[0] == ' ')
            t.erase(0, 1);
        while (!t.empty() && t.back() == ' ')
            t.pop_back();
        
        // Check for * (but not in template arguments)
        // Simple check: contains * and it's not inside <>
        int depth = 0;
        for (char c : t) {
            if (c == '<') depth++;
            else if (c == '>') depth--;
            else if (c == '*' && depth == 0) return true;
        }
        return false;
    }
    
    // Check if a type is a non-const reference type (e.g., "Model&", "arch::Model &")
    // but NOT const reference (const Model&)
    bool is_nonconst_reference_type(const std::string &type) const {
        // Check if it contains & but is NOT a const reference
        std::string t = type;
        
        // Trim whitespace
        while (!t.empty() && t[0] == ' ')
            t.erase(0, 1);
        while (!t.empty() && t.back() == ' ')
            t.pop_back();
        
        // Check for & (but not in template arguments)
        int depth = 0;
        bool has_ampersand = false;
        for (char c : t) {
            if (c == '<') depth++;
            else if (c == '>') depth--;
            else if (c == '&' && depth == 0) has_ampersand = true;
        }
        
        if (!has_ampersand) return false;
        
        // Check if it's const - if "const" appears before the type name, it's a const ref
        // e.g., "const Model&" or "const arch::Model &"
        if (t.find("const ") == 0) return false;
        if (t.find("const&") != std::string::npos) return false;
        
        return true;
    }
    
    // Strip the pointer from a type, returning the base type
    // "Model *" -> "Model", "arch::Model*" -> "arch::Model"
    std::string strip_pointer(const std::string &type) const {
        std::string t = type;
        // Remove const
        size_t pos;
        while ((pos = t.find("const ")) != std::string::npos)
            t.erase(pos, 6);
        // Remove &
        while ((pos = t.find("&")) != std::string::npos)
            t.erase(pos, 1);
        // Remove *
        while ((pos = t.find("*")) != std::string::npos)
            t.erase(pos, 1);
        // Trim whitespace
        while (!t.empty() && t[0] == ' ')
            t.erase(0, 1);
        while (!t.empty() && t.back() == ' ')
            t.pop_back();
        
        return t;
    }
    
    // Strip the reference from a type, returning the base type
    // "Model&" -> "Model", "arch::Model &" -> "arch::Model"
    std::string strip_reference(const std::string &type) const {
        std::string t = type;
        // Remove &
        size_t pos;
        while ((pos = t.find("&")) != std::string::npos)
            t.erase(pos, 1);
        // Trim whitespace
        while (!t.empty() && t[0] == ' ')
            t.erase(0, 1);
        while (!t.empty() && t.back() == ' ')
            t.pop_back();
        
        return t;
    }

    // Normalize type string - remove std::__1::, allocators, const, &, etc.
    // NOTE: Does NOT remove * - use strip_pointer for that
    std::string normalize_type(const std::string &t) const {
        std::string r = t;

        // Remove std::__1:: (libc++ internal namespace)
        size_t pos;
        while ((pos = r.find("std::__1::")) != std::string::npos) {
            r.replace(pos, 10, "std::");
        }

        // Remove allocator template arguments
        // Handle nested allocators like std::allocator<Surface>
        size_t alloc_start;
        while ((alloc_start = r.find(", std::allocator<")) != std::string::npos) {
            // Find the matching >
            size_t depth     = 1;
            size_t alloc_end = alloc_start + 17; // skip ", std::allocator<"
            while (alloc_end < r.size() && depth > 0) {
                if (r[alloc_end] == '<')
                    depth++;
                else if (r[alloc_end] == '>')
                    depth--;
                alloc_end++;
            }
            r.erase(alloc_start, alloc_end - alloc_start);
        }

        // Remove const and &
        while ((pos = r.find("const ")) != std::string::npos)
            r.erase(pos, 6);
        while ((pos = r.find("&")) != std::string::npos)
            r.erase(pos, 1);

        // Trim whitespace
        while (!r.empty() && r[0] == ' ')
            r.erase(0, 1);
        while (!r.empty() && r.back() == ' ')
            r.pop_back();

        return r;
    }

    // Check if type is a vector (handles various forms)
    bool is_vector_type(const std::string &type) const {
        std::string norm = normalize_type(type);
        return norm.find("vector<") != std::string::npos ||
               norm.find("std::vector<") != std::string::npos;
    }

    // Extract element type from vector, handling allocators properly
    std::string extract_vector_element_type(const std::string &type) const {
        std::string norm = normalize_type(type);

        size_t start = norm.find("vector<");
        if (start == std::string::npos)
            return "";
        start += 7; // skip "vector<"

        // Find matching > accounting for nested templates
        int    depth = 1;
        size_t end   = start;
        while (end < norm.size() && depth > 0) {
            if (norm[end] == '<')
                depth++;
            else if (norm[end] == '>')
                depth--;
            if (depth > 0)
                end++;
        }

        std::string elem = norm.substr(start, end - start);

        // Trim whitespace
        while (!elem.empty() && elem[0] == ' ')
            elem.erase(0, 1);
        while (!elem.empty() && elem.back() == ' ')
            elem.pop_back();

        return elem;
    }

    // Check if a type is a registered class
    bool is_registered_class(const std::string &type_name) const {
        auto       &registry = rosetta::Registry::instance();
        std::string norm     = normalize_type(type_name);
        
        // Strip pointer if present for the check
        std::string check_type = strip_pointer(norm);

        // Try the type name directly
        if (registry.get_by_name(check_type) != nullptr)
            return true;

        // Try stripping namespace
        size_t pos = check_type.rfind("::");
        if (pos != std::string::npos) {
            std::string short_name = check_type.substr(pos + 2);
            if (registry.get_by_name(short_name) != nullptr)
                return true;
        }

        // Also try the original type name
        if (registry.get_by_name(type_name) != nullptr)
            return true;

        return false;
    }

    bool needs_conversion(const std::string &type) const {
        if (type.find("vector<") != std::string::npos)
            return true;
        if (type.find("function") != std::string::npos)
            return true;

        // Check if it's a registered class type that needs wrapping
        std::string elem = extract_vector_element_type(type);
        if (!elem.empty() && is_registered_class(elem))
            return true;

        return false;
    }

    // Get the JavaScript/embind parameter type for a C++ type
    // For pointer types, returns a reference to the base type
    // For non-const references, keeps them as references
    std::string get_js_param_type(const std::string &type) const {
        if (is_vector_type(type))
            return "val";
        if (type.find("function") != std::string::npos)
            return "val";

        // Handle pointer types: convert to reference for embind compatibility
        if (is_pointer_type(type)) {
            std::string base = strip_pointer(type);
            return base + "&";  // Convert Model* to Model&
        }
        
        // Handle non-const reference types: keep as reference
        // embind can handle T& in lambda parameters
        if (is_nonconst_reference_type(type)) {
            std::string base = strip_reference(type);
            return base + "&";  // Keep as Model&
        }

        // For registered classes that need conversion
        std::string norm = normalize_type(type);
        if (is_registered_class(norm))
            return "val";

        return norm;
    }

    // Check if type is a std::function
    bool is_function_type(const std::string &type) const {
        std::string norm = normalize_type(type);
        return norm.find("function<") != std::string::npos ||
               norm.find("std::function<") != std::string::npos;
    }

    // Extract function signature from std::function<ReturnType(ParamTypes...)>
    struct FunctionSignature {
        std::string              return_type;
        std::vector<std::string> param_types;
    };

    FunctionSignature extract_function_signature(const std::string &type) const {
        FunctionSignature sig;
        std::string       norm = normalize_type(type);

        // Find "function<"
        size_t start = norm.find("function<");
        if (start == std::string::npos)
            return sig;
        start += 9; // skip "function<"

        // Find the return type (everything before the '(')
        size_t paren_start = norm.find('(', start);
        if (paren_start == std::string::npos)
            return sig;

        sig.return_type = norm.substr(start, paren_start - start);
        // Trim whitespace
        while (!sig.return_type.empty() && sig.return_type[0] == ' ')
            sig.return_type.erase(0, 1);
        while (!sig.return_type.empty() && sig.return_type.back() == ' ')
            sig.return_type.pop_back();

        // Find the closing paren
        size_t paren_end = norm.find(')', paren_start);
        if (paren_end == std::string::npos)
            return sig;

        // Extract parameter types
        std::string params_str = norm.substr(paren_start + 1, paren_end - paren_start - 1);

        // Split by comma, accounting for nested templates
        if (!params_str.empty()) {
            int    depth      = 0;
            size_t last_start = 0;
            for (size_t i = 0; i <= params_str.size(); ++i) {
                if (i == params_str.size() || (params_str[i] == ',' && depth == 0)) {
                    std::string param = params_str.substr(last_start, i - last_start);
                    // Trim whitespace
                    while (!param.empty() && param[0] == ' ')
                        param.erase(0, 1);
                    while (!param.empty() && param.back() == ' ')
                        param.pop_back();
                    if (!param.empty()) {
                        sig.param_types.push_back(param);
                    }
                    last_start = i + 1;
                } else if (params_str[i] == '<') {
                    depth++;
                } else if (params_str[i] == '>') {
                    depth--;
                }
            }
        }

        return sig;
    }

    // Generate input conversion for a parameter
    // For pointer types, adds & to get address from reference
    std::string generate_input_conversion(const std::string &type, const std::string &var) const {
        std::string norm = normalize_type(type);

        // Handle std::function types
        if (is_function_type(norm)) {
            return generate_function_conversion(type, var);
        }

        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "typedArrayToVectorDouble(" + var + ")";
            }
            if (elem == "int") {
                return "typedArrayToVectorInt(" + var + ")";
            }
            // For vectors of registered classes
            if (is_registered_class(elem)) {
                return "jsArrayToVector<" + elem + ">(" + var + ")";
            }
            // Generic case
            return "jsArrayToVector<" + elem + ">(" + var + ")";
        }

        // Handle pointer types: take address of the reference
        if (is_pointer_type(type)) {
            return "&" + var;  // Convert Model& back to Model*
        }

        return var;
    }

    // Generate conversion code for std::function from JavaScript function
    std::string generate_function_conversion(const std::string &type, const std::string &var) const {
        auto sig = extract_function_signature(type);

        if (sig.return_type.empty()) {
            // Fallback if parsing failed
            return var;
        }

        std::ostringstream oss;

        // Create a lambda that wraps the JavaScript function
        oss << "[" << var << "](";

        // Generate parameter list
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << sig.param_types[i] << " p" << i;
        }
        oss << ") -> " << sig.return_type << " {\n";
        oss << "                return " << var << "(";

        // Pass parameters to JS function
        for (size_t i = 0; i < sig.param_types.size(); ++i) {
            if (i > 0)
                oss << ", ";
            oss << "p" << i;
        }
        oss << ").template as<" << sig.return_type << ">();\n";
        oss << "            }";

        return oss.str();
    }

    std::string generate_output_conversion(const std::string &type, const std::string &var) const {
        std::string norm = normalize_type(type);

        // Handle vectors
        if (is_vector_type(norm)) {
            std::string elem = extract_vector_element_type(norm);
            if (elem == "double") {
                return "vectorDoubleToTypedArray(" + var + ")";
            }
            if (elem == "int") {
                return "vectorIntToTypedArray(" + var + ")";
            }
            // For vectors of registered classes - use template version
            return "vectorToJsArray<" + elem + ">(" + var + ")";
        }

        return var;
    }
};