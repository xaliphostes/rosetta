┌─────────────────────────────────────────────────────────────────────────┐
│             ROSETTA N-API BINDINGS - ARCHITECTURE OVERVIEW              │
└─────────────────────────────────────────────────────────────────────────┘

1. REGISTRATION PHASE (C++ compile time)
   ────────────────────────────────────

   User Code:                    Rosetta Registry:
   ┌──────────────┐             ┌─────────────────────┐
   │ class Vec3D  │────────────>│ ClassMetadata<Vec3D>│
   │  double x,y,z│             │  - fields[]         │
   │  length()    │             │  - methods[]        │
   │  normalize() │             │  - constructors[]   │
   └──────────────┘             │  - inheritance      │
                                └─────────────────────┘
   
   ROSETTA_REGISTER_CLASS(Vec3D)
       .field("x", &Vec3D::x)
       .method("length", &Vec3D::length)
   
   All metadata stored in Registry singleton


2. BINDING GENERATION PHASE (N-API module init)
   ─────────────────────────────────────────────

   ClassWrapper<Vec3D>::Init(env, exports, "Vector3D")
   │
   ├─> For each field in metadata:
   │   └─> Create property descriptor (getter/setter)
   │
   └─> For each method in metadata:
       └─> Create method descriptor
   
   Result: JavaScript constructor function with prototype


3. TYPE CONVERSION SYSTEM
   ───────────────────────

   ┌──────────────┐                            ┌──────────────┐
   │ JS: Number   │──> TypeSystem::JSToAny ──> │ rosetta::Any │
   │ JS: Array    │                            │(type-erased) │
   │ JS: Object   │<── TypeSystem::AnyToJS <── │              │
   │ JS: Function │                            └──────────────┘
   └──────────────┘
   
   Conversion Rules:
   • Primitives: Direct mapping (Number ↔ double/int)
   • Containers: Recursive conversion (Array ↔ vector<T>)
   • Objects: Field-by-field (Object ↔ CustomClass)
   • Functions: Thread-safe function wrapper (Function ↔ std::function)


4. RUNTIME EXECUTION FLOW
   ───────────────────────

   JavaScript:              N-API:               Rosetta:              C++:
   ┌──────────┐           ┌───────────┐          ┌──────────┐         ┌──────┐
   │vec.length│──────────>│ CallMethod│────────> │ invoke_  │────────>│length│
   │  ()      │           │           │          │ method() │         │ ()   │
   └──────────┘           └───────────┘          └──────────┘         └──────┘
        ↑                       │                    │                   │
        │                       │                    │                   │
        └───────────────────────┴────────────────────┴───────────────────┘
                          Return value converted back


5. DETAILED CALL SEQUENCE
   ───────────────────────

   vec.length() in JavaScript triggers:
   
   1. V8 calls N-API wrapper
      └─> Napi::CallbackInfo received
   
   2. ClassWrapper<Vec3D>::CallMethod
      ├─> Extract method name from CallbackInfo.Data()
      ├─> Get metadata: Registry::instance().get<Vec3D>()
      └─> Get argument types: meta.get_method_arg_types("length")
   
   3. Convert arguments
      └─> For each JS arg: TypeSystem::JSToAny(arg, expected_type)
          ├─> Check type_index
          ├─> Call appropriate converter
          └─> Return rosetta::Any
   
   4. Invoke C++ method
      └─> meta.invoke_method(instance, "length", args)
          ├─> Look up method in registry
          ├─> Unwrap Any arguments
          ├─> Call actual C++ method via function pointer
          └─> Wrap result in Any
   
   5. Convert result back
      └─> TypeSystem::AnyToJS(env, result)
          ├─> Check result type_index
          ├─> Call appropriate converter
          └─> Return Napi::Value
   
   6. V8 receives result
      └─> JavaScript continues execution


6. CONTAINER HANDLING
   ───────────────────

   Example: vector<double>
   
   JS Array [1, 2, 3]
      │
      ├─> TypeSystem::VectorDoubleFromJS()
      │   ├─> Create empty std::vector<double>
      │   ├─> For each element:
      │   │   ├─> arr.Get(i)
      │   │   ├─> ToNumber().DoubleValue()
      │   │   └─> vec.push_back(value)
      │   └─> Return Any(vec)
      │
      └─> Stored in C++ as native std::vector<double>
   
   Reverse (C++ → JS):
      std::vector<double> vec
      │
      └─> TypeSystem::VectorDoubleToJS()
          ├─> Create Napi::Array
          ├─> For each element:
          │   └─> arr[i] = Napi::Number::New(env, vec[i])
          └─> Return Napi::Array


7. FUNCTOR HANDLING (JS callbacks from C++)
   ────────────────────────────────────────

   JavaScript:
   obj.calculator = (x, y) => x + y;
   
   Conversion:
   ┌─────────────────────────────────────────────────────┐
   │ FunctorDoubleDoubleFromJS                           │
   ├─────────────────────────────────────────────────────┤
   │ 1. Create ThreadSafeFunction (stores JS function)   │
   │ 2. Create std::function<double(double,double)>:     │
   │    └─> Lambda captures ThreadSafeFunction           │
   │    └─> When called:                                 │
   │        ├─> Convert C++ args to JS                   │
   │        ├─> tsfn.BlockingCall(jsFunc)                │
   │        ├─> jsFunc.Call(js_args)                     │
   │        └─> Convert JS result back to C++            │
   │ 3. Store in rosetta::Any                            │
   └─────────────────────────────────────────────────────┘
   
   When C++ calls the functor:
   C++: result = obj.calculator(10, 20)
      │
      └─> Calls lambda in std::function
          └─> ThreadSafeFunction executes JS callback
              └─> JS: (10, 20) => 10 + 20 = 30
                  └─> Converted back to C++ double


8. MEMORY MANAGEMENT
   ──────────────────

   Ownership:
   • ClassWrapper owns C++ object via shared_ptr
   • JavaScript GC manages ClassWrapper lifetime
   • When JS object collected → ClassWrapper destructor → shared_ptr released
   
   Thread Safety:
   • ThreadSafeFunction for JS callbacks
   • All N-API calls happen on Node.js event loop
   • No raw pointers exposed to JavaScript
   
   Any Storage:
   • rosetta::Any uses type erasure (virtual Holder)
   • Stores copy of value, not pointer
   • Safe to pass between C++ and JS


9. ERROR HANDLING
   ──────────────

   C++ Exception                    JavaScript Error
   ┌───────────────┐               ┌──────────────┐
   │ std::bad_cast │──────────────>│ TypeError    │
   │ out_of_range  │               │ RangeError   │
   │ runtime_error │               │ Error        │
   └───────────────┘               └──────────────┘
   
   try {
       meta.invoke_method(...)
   } catch (const std::exception &e) {
       Napi::Error::New(env, e.what()).ThrowAsJavaScriptException();
       return env.Undefined();
   }


10. KEY CLASSES AND THEIR ROLES
    ───────────────────────────

    TypeSystem
    └─> JSToAny(value, type_index) -> Any
    └─> AnyToJS(any) -> Napi::Value
        • Central type conversion hub
        • Handles primitives, containers, objects, functors
    
    ClassWrapper<T>
    └─> Napi::ObjectWrap template
    └─> Owns std::shared_ptr<T>
    └─> Generates property/method descriptors from metadata
        • Generic wrapper for any registered class
        • One instantiation per C++ class type
    
    ContainerConverterRegistry
    └─> Specialized converters for STL types
    └─> Extensible for custom containers
        • Handles vector, array, map, set
        • Recursive conversion for nested types
    
    ClassMetadata<T> (from Rosetta)
    └─> Fields, methods, constructors
    └─> Type information via type_index
    └─> Dynamic invocation via Any
        • Source of truth for class structure
        • Enables reflection-based binding


11. ADDING A NEW TYPE
    ──────────────────

    Step 1: Add to TypeSystem::JSToAny
    ─────────────────────────────────
    if (target_type == std::type_index(typeid(MyType))) {
        return MyTypeFromJS(env, val);
    }
    
    Step 2: Add to TypeSystem::AnyToJS
    ───────────────────────────────────
    if (ti == std::type_index(typeid(MyType))) {
        return MyTypeToJS(env, any.as<MyType>());
    }
    
    Step 3: Implement converters
    ────────────────────────────
    static Any MyTypeFromJS(Napi::Env env, const Napi::Value &val) {
        // Convert JS representation to C++ MyType
        MyType obj = ...;
        return Any(obj);
    }
    
    static Napi::Value MyTypeToJS(Napi::Env env, const MyType &obj) {
        // Convert C++ MyType to JS representation
        Napi::Object jsObj = ...;
        return jsObj;
    }
    
    Step 4: Register with Rosetta
    ──────────────────────────────
    ROSETTA_REGISTER_CLASS(MyType)
        .field(...)
        .method(...);
    
    Step 5: Add to module Init
    ───────────────────────────
    ClassWrapper<MyType>::Init(env, exports, "MyType");


12. PERFORMANCE CONSIDERATIONS
    ───────────────────────────

    Optimizations:
    • Type dispatch via std::type_index (O(1) hash lookup)
    • Minimal allocations (Any reuses storage)
    • No RTTI overhead beyond initial type registration
    • Zero-copy for primitives
    • Shared ownership avoids unnecessary copies
    
    Bottlenecks:
    • Container conversion (must copy elements)
    • ThreadSafeFunction has some overhead
    • Any type erasure has virtual call cost
    
    Best Practices:
    • Pass large objects by reference
    • Use readonly_property for computed values
    • Batch operations when possible
    • Cache metadata lookups if calling repeatedly


13. COMPARISON WITH OTHER APPROACHES
    ────────────────────────────────

    Manual Bindings (traditional):
    ✗ Must write wrapper for each class/method
    ✗ Type conversion code is repetitive
    ✗ Hard to maintain as API changes
    ✓ Maximum control and optimization
    
    SWIG:
    ✓ Automatic binding generation
    ✗ Requires interface files (.i)
    ✗ Limited introspection
    ✗ Complex build process
    
    Embind (Emscripten):
    ✓ Elegant C++ API
    ✗ Only for WebAssembly
    ✗ Different threading model
    
    Rosetta + N-API (this system):
    ✓ Fully automatic from Rosetta metadata
    ✓ No interface files needed
    ✓ Full introspection at runtime
    ✓ Native Node.js integration
    ✓ Extensible type system
    ✗ Requires Rosetta registration
    ✗ Some runtime overhead from reflection


14. FUTURE ENHANCEMENTS
    ────────────────────

    Planned:
    • Automatic container type detection
    • Template class support
    • Property generation from getter/setters
    • Async method support (Promise return)
    • Stream support for large data
    • Worker thread support
    • TypeScript definition generation
    • Better error messages with type names
    • Performance profiling integration
    • Multiple inheritance support
