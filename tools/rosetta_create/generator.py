"""
Project generator for Rosetta binding projects.
"""

import os
import shutil
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional


@dataclass
class LibrarySource:
    """Configuration for the library source."""
    source_type: str  # "fetch" or "local"
    git_repo: str = ""
    git_tag: str = "main"
    local_path: str = ""


@dataclass
class ProjectConfig:
    """Configuration for the generated project."""
    name: str
    lib_name: str
    lib_source: LibrarySource

    description: str = ""
    author: str = ""
    version: str = "1.0.0"
    license: str = "MIT"

    lib_include_subdir: str = "include"
    lib_src_subdir: str = "src"

    namespace: str = ""
    registration_namespace: str = ""

    targets: List[str] = field(default_factory=lambda: ["python"])
    output_dir: str = ""

    def __post_init__(self):
        if not self.namespace:
            self.namespace = self.lib_name
        if not self.registration_namespace:
            self.registration_namespace = f"{self.safe_name}_rosetta"
        if not self.output_dir:
            self.output_dir = f"./{self.name}"

    @property
    def safe_name(self) -> str:
        """Project name safe for use in code (underscores instead of hyphens)."""
        return self.name.replace("-", "_")


class ProjectGenerator:
    """Generates a Rosetta binding project from configuration."""

    def __init__(self, config: ProjectConfig):
        self.config = config
        self.output_path = Path(config.output_dir).resolve()

    def generate(self, force: bool = False):
        """Generate the project."""
        # Check if output directory exists
        if self.output_path.exists():
            if not force:
                raise FileExistsError(
                    f"Directory {self.output_path} already exists. Use --force to overwrite."
                )
            shutil.rmtree(self.output_path)

        # Create directory structure
        self.output_path.mkdir(parents=True)
        (self.output_path / "bindings").mkdir()

        # Generate files
        self._write_cmake()
        self._write_main()
        self._write_registration()
        self._write_project_json()
        self._write_readme()
        self._write_gitignore()

        print(f"Created project at: {self.output_path}")

    def _write_file(self, filename: str, content: str):
        """Write a file to the output directory."""
        filepath = self.output_path / filename
        filepath.parent.mkdir(parents=True, exist_ok=True)
        filepath.write_text(content)
        print(f"  Created: {filename}")

    def _write_cmake(self):
        """Generate CMakeLists.txt."""
        c = self.config

        # Library fetching section
        if c.lib_source.source_type == "fetch":
            lib_fetch = f'''# ----------------------------------------------------------------------------
# {c.lib_name} Library (fetched from GitHub)
# ----------------------------------------------------------------------------
message(STATUS "Fetching {c.lib_name} library...")
FetchContent_Declare(
    {c.lib_name}
    GIT_REPOSITORY {c.lib_source.git_repo}
    GIT_TAG        {c.lib_source.git_tag}
    GIT_SHALLOW    TRUE
)

# Disable tests for fetched library
set(BUILD_TESTING OFF CACHE BOOL "" FORCE)

FetchContent_MakeAvailable({c.lib_name})
FetchContent_GetProperties({c.lib_name} SOURCE_DIR {c.lib_name.upper()}_SOURCE_DIR)
set({c.lib_name.upper()}_INCLUDE_DIR "${{{c.lib_name.upper()}_SOURCE_DIR}}/{c.lib_include_subdir}")
set({c.lib_name.upper()}_SRC_DIR "${{{c.lib_name.upper()}_SOURCE_DIR}}/{c.lib_src_subdir}")'''
        else:
            lib_fetch = f'''# ----------------------------------------------------------------------------
# {c.lib_name} Library (local path)
# ----------------------------------------------------------------------------
set({c.lib_name.upper()}_SOURCE_DIR "{c.lib_source.local_path}")
set({c.lib_name.upper()}_INCLUDE_DIR "${{{c.lib_name.upper()}_SOURCE_DIR}}/{c.lib_include_subdir}")
set({c.lib_name.upper()}_SRC_DIR "${{{c.lib_name.upper()}_SOURCE_DIR}}/{c.lib_src_subdir}")

if(NOT EXISTS ${{{c.lib_name.upper()}_SOURCE_DIR}})
    message(FATAL_ERROR "{c.lib_name} not found at: ${{{c.lib_name.upper()}_SOURCE_DIR}}")
endif()'''

        content = f'''# ============================================================================
# CMakeLists.txt for {c.name}
# ============================================================================
# Generated by rosetta-create
#
# Usage:
#   mkdir build && cd build
#   cmake ..
#   make
#   ./{c.safe_name}_generator project.json
# ============================================================================

cmake_minimum_required(VERSION 3.16)
project({c.safe_name}_binding_generator VERSION {c.version} LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

# ============================================================================
# FetchContent for dependencies
# ============================================================================
include(FetchContent)

# ----------------------------------------------------------------------------
# Rosetta Library
# ----------------------------------------------------------------------------
message(STATUS "Fetching Rosetta library...")
FetchContent_Declare(
    rosetta
    GIT_REPOSITORY https://github.com/xaliphostes/rosetta.git
    GIT_TAG        main
    GIT_SHALLOW    TRUE
)

# Disable Rosetta unit tests
set(BUILD_TESTING OFF CACHE BOOL "" FORCE)

FetchContent_MakeAvailable(rosetta)
FetchContent_GetProperties(rosetta SOURCE_DIR ROSETTA_SOURCE_DIR)
set(ROSETTA_INCLUDE_DIR "${{ROSETTA_SOURCE_DIR}}/include")

{lib_fetch}

# ----------------------------------------------------------------------------
# nlohmann_json (for configuration parsing)
# ----------------------------------------------------------------------------
find_package(nlohmann_json 3.9 QUIET)
if(NOT nlohmann_json_FOUND)
    message(STATUS "Fetching nlohmann_json...")
    FetchContent_Declare(
        nlohmann_json
        GIT_REPOSITORY https://github.com/nlohmann/json.git
        GIT_TAG        v3.11.3
        GIT_SHALLOW    TRUE
    )
    FetchContent_MakeAvailable(nlohmann_json)
endif()

# ============================================================================
# Generator executable
# ============================================================================
add_executable({c.safe_name}_generator
    main.cxx
)

# Place the executable in a convenient location
set_target_properties({c.safe_name}_generator PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${{CMAKE_BINARY_DIR}}/.."
)

# Include directories
target_include_directories({c.safe_name}_generator PRIVATE
    # Rosetta
    ${{ROSETTA_INCLUDE_DIR}}

    # {c.lib_name} library headers
    ${{{c.lib_name.upper()}_INCLUDE_DIR}}
    ${{{c.lib_name.upper()}_SRC_DIR}}

    # Local bindings directory
    ${{CMAKE_CURRENT_SOURCE_DIR}}
    ${{CMAKE_CURRENT_SOURCE_DIR}}/bindings
)

# Link libraries
target_link_libraries({c.safe_name}_generator PRIVATE
    nlohmann_json::nlohmann_json
)

# ============================================================================
# Print configuration summary
# ============================================================================
message(STATUS "")
message(STATUS "============================================================")
message(STATUS "{c.name} Binding Generator Configuration")
message(STATUS "============================================================")
message(STATUS "  {c.lib_name} source:      ${{{c.lib_name.upper()}_SOURCE_DIR}}")
message(STATUS "  Rosetta include:      ${{ROSETTA_INCLUDE_DIR}}")
message(STATUS "============================================================")
message(STATUS "")
message(STATUS "  1. Build: cmake --build .")
message(STATUS "  2. Run: ./{c.safe_name}_generator project.json")
'''
        self._write_file("CMakeLists.txt", content)

    def _write_main(self):
        """Generate main.cxx."""
        c = self.config

        content = f'''// ============================================================================
// Binding Generator for {c.name}
// ============================================================================
// Generated by rosetta-create
//
// This generator compiles the project and calls the Rosetta registration
// function BEFORE generating bindings, so the generator can discover all
// registered classes.
// ============================================================================

#include <rosetta/extensions/generators/common/BindingGeneratorLib.h>
#include "{c.safe_name}_registration.h"

int main(int argc, char* argv[]) {{
    // IMPORTANT: Call registration BEFORE running the generator
    // This populates rosetta::Registry::instance() with class metadata
    {c.registration_namespace}::register_all();

    // Now run the binding generator
    // It will query the registry and find all registered classes
    return BindingGeneratorLib::run(argc, argv);
}}
'''
        self._write_file("main.cxx", content)

    def _write_registration(self):
        """Generate the registration header."""
        c = self.config

        content = f'''// ============================================================================
// {c.lib_name} Library Rosetta Registration
// ============================================================================
// Generated by rosetta-create
//
// This file registers {c.lib_name} classes with Rosetta for introspection.
//
// IMPORTANT: For overloaded functions, use FULLY QUALIFIED type names
// because the macro stringifies the type and it must be valid C++ in the
// generated binding file.
// ============================================================================
#pragma once

#include <rosetta/rosetta.h>

// TODO: Add your library headers here
// #include <{c.lib_name}/your_header.h>

namespace {c.registration_namespace} {{

    inline void register_all() {{
        using namespace rosetta::core;
        auto &registry      = Registry::instance();
        auto &func_registry = FunctionRegistry::instance();

        // ====================================================================
        // Register your classes here
        // ====================================================================
        //
        // Example class registration:
        //
        // ROSETTA_REGISTER_CLASS({c.namespace}::MyClass)
        //     .constructor<>()
        //     .constructor<int, float>()
        //     .method("get_value", &{c.namespace}::MyClass::get_value)
        //     .method("set_value", &{c.namespace}::MyClass::set_value)
        //     .field("name", &{c.namespace}::MyClass::name);
        //
        // ====================================================================
        // Register your functions here
        // ====================================================================
        //
        // Example function registration:
        //
        // ROSETTA_REGISTER_FUNCTION({c.namespace}::my_function);
        //
        // For overloaded functions:
        //
        // ROSETTA_REGISTER_OVERLOADED_FUNCTION(
        //     {c.namespace}::overloaded_func,
        //     void (*)({c.namespace}::MyClass&, int)
        // );
        //
        // ROSETTA_REGISTER_OVERLOADED_FUNCTION_AS(
        //     {c.namespace}::overloaded_func,
        //     "overloaded_func_float",
        //     void (*)({c.namespace}::MyClass&, float)
        // );

        // TODO: Add your registrations below

    }}

}} // namespace {c.registration_namespace}
'''
        self._write_file(f"bindings/{c.safe_name}_registration.h", content)

    def _write_project_json(self):
        """Generate project.json."""
        c = self.config

        # Build targets section
        targets_json = []
        for target in c.targets:
            if target == "python":
                targets_json.append(f'''        "python": {{
            "enabled": true,
            "python_executable": "",
            "module_name": "{c.lib_name}",
            "output_dir": "",
            "link_mode": "static",
            "sources": {{
                "glob_patterns": ["**/*.cpp"],
                "exclude_patterns": ["**/test/**", "**/main.cpp", "**/examples/**"]
            }}
        }}''')
            elif target == "wasm":
                targets_json.append(f'''        "wasm": {{
            "enabled": true,
            "module_name": "{c.lib_name}_wasm",
            "output_dir": "",
            "single_file": true,
            "export_es6": false,
            "environment": "web,node"
        }}''')
            elif target == "javascript":
                targets_json.append(f'''        "javascript": {{
            "enabled": true,
            "module_name": "{c.lib_name}_js",
            "output_dir": ""
        }}''')
            elif target == "rest":
                targets_json.append(f'''        "rest": {{
            "enabled": true,
            "output_dir": ""
        }}''')

        # Add disabled targets
        all_targets = ["python", "wasm", "javascript"]
        for target in all_targets:
            if target not in c.targets:
                if target == "python":
                    targets_json.append(f'''        "python": {{
            "enabled": false,
            "module_name": "{c.lib_name}",
            "output_dir": ""
        }}''')
                elif target == "wasm":
                    targets_json.append(f'''        "wasm": {{
            "enabled": false,
            "module_name": "{c.lib_name}_wasm",
            "output_dir": ""
        }}''')
                elif target == "javascript":
                    targets_json.append(f'''        "javascript": {{
            "enabled": false,
            "module_name": "{c.lib_name}_js",
            "output_dir": ""
        }}''')

        # Library path variables
        if c.lib_source.source_type == "fetch":
            lib_root_var = f'"${{BUILD_DIR}}/_deps/{c.lib_name}-src"'
        else:
            lib_root_var = f'"{c.lib_source.local_path}"'

        content = f'''{{
    "variables": {{
        "BUILD_DIR": "build",
        "ROSETTA_ROOT": "${{BUILD_DIR}}/_deps/rosetta-src",
        "{c.lib_name.upper()}_ROOT": {lib_root_var}
    }},

    "project": {{
        "name": "{c.lib_name}",
        "version": "{c.version}",
        "description": "{c.description}",
        "author": "{c.author}",
        "license": "{c.license}"
    }},

    "rosetta": {{
        "registration_header": "bindings/{c.safe_name}_registration.h",
        "registration_function": "{c.registration_namespace}::register_all"
    }},

    "output_base_dir": "generated",

    "sources": {{
        "mode": "static",
        "base_dir": "${{{c.lib_name.upper()}_ROOT}}/{c.lib_src_subdir}",
        "files": [],
        "glob_patterns": [
            "**/*.cpp"
        ],
        "exclude_patterns": [
            "**/test/**",
            "**/*_test.cpp",
            "**/examples/**",
            "**/main.cpp"
        ]
    }},

    "includes": {{
        "directories": [
            "${{{c.lib_name.upper()}_ROOT}}/{c.lib_include_subdir}",
            "${{{c.lib_name.upper()}_ROOT}}/{c.lib_src_subdir}",
            "${{ROSETTA_ROOT}}/include"
        ],
        "headers": [],
        "library_directories": [],
        "libraries": []
    }},

    "targets": {{
{chr(44).join(targets_json)}
    }},

    "types": {{
        "namespace": "{c.namespace}"
    }}
}}
'''
        self._write_file("project.json", content)

    def _write_readme(self):
        """Generate README.md."""
        c = self.config

        targets_list = ", ".join(c.targets)

        content = f'''# {c.name}

{c.description}

## Prerequisites

- CMake 3.16+
- C++20 compatible compiler
- Python 3.8+ (for Python bindings)

## Building

```bash
# Create build directory
mkdir build && cd build

# Configure
cmake ..

# Build the generator
make

# Run the generator
cd ..
./{c.safe_name}_generator project.json
```

## Generated Bindings

This project generates bindings for: {targets_list}

After running the generator, you'll find the generated code in the `generated/` directory.

### Python Bindings

```bash
cd generated/python
pip install .
```

Then in Python:

```python
import {c.lib_name}
# Use your bound classes and functions
```

## Customizing Bindings

Edit `bindings/{c.safe_name}_registration.h` to register your C++ classes and functions.

See the [Rosetta documentation](https://github.com/xaliphostes/rosetta) for more information on registration macros.

## License

{c.license}
'''
        self._write_file("README.md", content)

    def _write_gitignore(self):
        """Generate .gitignore."""
        content = '''# Build directories
build/
generated/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Compiled files
*.o
*.a
*.so
*.dylib

# Executables
*_generator

# Python
__pycache__/
*.pyc
*.pyo
*.egg-info/
dist/
*.whl

# OS
.DS_Store
Thumbs.db
'''
        self._write_file(".gitignore", content)
