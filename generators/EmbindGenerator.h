#pragma once
#include "CodeWriter.h"
#include <rosetta/rosetta.h>

// ============================================================================
// Embind C++ Code Generator
// Generates WebAssembly bindings from Rosetta metadata
// ============================================================================

class EmbindGenerator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_helpers();
        write_bindings();
    }

private:
    void write_header() {
        line("// ============================================================================");
        line("// AUTO-GENERATED EMSCRIPTEN BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// Module: " + config_.module_name);
        line("// ============================================================================");
        line();
    }

    void write_includes() {
        line("#include <emscripten/bind.h>");
        line("#include <emscripten/val.h>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();
        
        // Include source headers from config
        if (!config_.source_headers.empty()) {
            line("// Project headers");
            for (const auto& header : config_.source_headers) {
                line("#include <" + header + ">");
            }
            line();
        }
        
        // Include registration header
        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
            line();
        }
        
        line("using namespace emscripten;");
        line();
    }

    void write_helpers() {
        line("// ============================================================================");
        line("// JavaScript TypedArray <-> C++ conversion helpers");
        line("// ============================================================================");
        line();

        // Generic vector conversions
        line("template<typename T>");
        line("std::vector<T> jsArrayToVector(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<T> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<T>();");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("template<typename T>");
        line("val vectorToJsArray(const std::vector<T>& vec) {");
        indent();
        line("val arr = val::global(\"Array\").new_();");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.call<void>(\"push\", vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        // Float64Array for double vectors
        line("val vectorDoubleToTypedArray(const std::vector<double>& vec) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        // 3-element vector helpers
        line("template<typename Vec3>");
        line("Vec3 jsArrayToVec3(const val& arr) {");
        indent();
        line("return Vec3(arr[0].as<double>(), arr[1].as<double>(), arr[2].as<double>());");
        dedent();
        line("}");
        line();

        line("template<typename Vec3>");
        line("val vec3ToJsArray(const Vec3& v) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(3);");
        line("arr.set(0, v[0]); arr.set(1, v[1]); arr.set(2, v[2]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        // 3x3 matrix helpers
        line("template<typename Mat33>");
        line("val mat33ToJsArray(const Mat33& m) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(9);");
        line("for (int i = 0; i < 3; ++i)");
        line("    for (int j = 0; j < 3; ++j)");
        line("        arr.set(i * 3 + j, m.get(i, j));");
        line("return arr;");
        dedent();
        line("}");
        line();
    }

    void write_bindings() {
        line("// ============================================================================");
        line("// Embind Module Definition");
        line("// ============================================================================");
        line();
        line("EMSCRIPTEN_BINDINGS(" + config_.module_name + "_module) {");
        indent();
        line();
        
        // Call registration function
        if (!config_.registration_function.empty()) {
            line("// Register classes with Rosetta");
            line(config_.get_registration_call() + ";");
            line();
        }

        line("// Get registry for class information");
        line("auto& registry = rosetta::Registry::instance();");
        line();

        // Placeholder for generated class bindings
        line("// --- Generated class bindings would appear here ---");
        line("// The generator queries rosetta::Registry::instance() at generation time");
        line("// and emits specific class_<T> definitions for each registered class.");
        line();

        write_utility_functions();

        dedent();
        line("}");
    }

    void write_utility_functions() {
        line("// Utility functions for introspection");
        line("function(\"listClasses\", &[]() {");
        indent();
        line("return rosetta::Registry::instance().list_classes();");
        dedent();
        line("});");
        line();
        
        line("function(\"getClassMethods\", &[](const std::string& name) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + name);");
        line("return h->get_methods();");
        dedent();
        line("});");
        line();
        
        line("function(\"version\", &[]() {");
        indent();
        line("return rosetta::version();");
        dedent();
        line("});");
    }

    // ========================================================================
    // Methods for generating with live Rosetta data
    // ========================================================================

public:
    void write_class_binding(const std::string& name,
                             rosetta::core::Registry::MetadataHolder* h) {
        if (config_.should_skip_class(name)) {
            line("// Skipped: " + name);
            return;
        }

        line("// --- " + name + " ---");
        std::string cpp_type = h->get_cpp_type_name();
        auto base = h->get_base_class();

        if (!base.empty()) {
            line("class_<" + cpp_type + ", base<" + base + ">>(\"" + name + "\")");
        } else {
            line("class_<" + cpp_type + ">(\"" + name + "\")");
        }
        indent();
        
        // Smart pointer support
        line(".smart_ptr<std::shared_ptr<" + cpp_type + ">>(\"" + name + "Ptr\")");

        // Constructors
        for (const auto& ctor : h->get_constructors()) {
            auto params = ctor.get_param_types();
            if (params.empty()) {
                line(".constructor<>()");
            } else {
                std::string p;
                for (size_t i = 0; i < params.size(); ++i) {
                    if (i > 0) p += ", ";
                    p += params[i];
                }
                line(".constructor<" + p + ">()");
            }
        }

        // Methods
        for (const auto& m : h->get_methods()) {
            if (!config_.should_skip_method(name, m)) {
                line(".function(\"" + m + "\", &" + cpp_type + "::" + m + ")");
            }
        }

        line(";");
        dedent();
        line();
    }
};
