#pragma once
#include "CodeWriter.h"
#include <rosetta/rosetta.h>
#include <typeindex>

class Pybind11Generator : public CodeWriter {
  public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_numpy_helpers();
        write_module();
    }

  private:
    void write_header() {
        line("// "
             "================================================================="
             "===========");
        line("// AUTO-GENERATED PYBIND11 BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// "
             "================================================================="
             "===========");
        line();
    }

    void write_includes() {
        line("#include <pybind11/pybind11.h>");
        line("#include <pybind11/stl.h>");
        line("#include <pybind11/numpy.h>");
        line("#include <pybind11/functional.h>");
        line("#include <pybind11/operators.h>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();
        line("// Arch headers");
        for (const auto &header : config_.source_headers) {
            line("#include <" + header + ">");
        }
        line();
        
        // Include registration header from config
        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
        }
        line();
        line("namespace py = pybind11;");
        line("using namespace pybind11::literals;");
        line();
    }

    void write_numpy_helpers() {
        line("// "
             "================================================================="
             "===========");
        line("// NumPy <-> C++ conversion helpers");
        line("// "
             "================================================================="
             "===========");
        line("namespace {");
        line();
        indent();

        // Get namespace prefix (e.g., "arch::" or "mylib::" or "")
        std::string ns = config_.types_namespace.empty() 
            ? "" 
            : config_.types_namespace + "::";

        // Vector3 conversions
        line("py::array_t<double> vector3_to_numpy(const " + ns + "Vector3& v) {");
        indent();
        line("py::array_t<double> arr(3);");
        line("auto buf = arr.mutable_unchecked<1>();");
        line("buf(0) = v[0]; buf(1) = v[1]; buf(2) = v[2];");
        line("return arr;");
        dedent();
        line("}");
        line();

        line(ns + "Vector3 numpy_to_vector3(py::array_t<double> arr) {");
        indent();
        line("if (arr.size() != 3) throw std::runtime_error(\"Expected array "
             "of size 3\");");
        line("auto buf = arr.unchecked<1>();");
        line("return " + ns + "Vector3(buf(0), buf(1), buf(2));");
        dedent();
        line("}");
        line();

        // Matrix33 conversions
        line(
            "py::array_t<double> matrix33_to_numpy(const " + ns + "Matrix33& m) {");
        indent();
        line("py::array_t<double> arr({3, 3});");
        line("auto buf = arr.mutable_unchecked<2>();");
        line("buf(0,0) = m.get(0,0); buf(0,1) = m.get(0,1); buf(0,2) = "
             "m.get(0,2);");
        line("buf(1,0) = m.get(0,1); buf(1,1) = m.get(1,1); buf(1,2) = "
             "m.get(1,2);");
        line("buf(2,0) = m.get(0,2); buf(2,1) = m.get(1,2); buf(2,2) = "
             "m.get(2,2);");
        line("return arr;");
        dedent();
        line("}");
        line();

        // std::vector conversions
        line("py::array_t<double> vector_double_to_numpy(const "
             "std::vector<double>& vec) {");
        indent();
        line("return py::array_t<double>(vec.size(), vec.data());");
        dedent();
        line("}");
        line();

        line("std::vector<double> numpy_to_vector_double(py::array_t<double> "
             "arr) {");
        indent();
        line("auto buf = arr.unchecked<1>();");
        line("return std::vector<double>(buf.data(0), buf.data(0) + "
             "buf.size());");
        dedent();
        line("}");
        line();

        line("py::array_t<int> vector_int_to_numpy(const std::vector<int>& "
             "vec) {");
        indent();
        line("return py::array_t<int>(vec.size(), vec.data());");
        dedent();
        line("}");
        line();

        line("std::vector<int> numpy_to_vector_int(py::array_t<int> arr) {");
        indent();
        line("auto buf = arr.unchecked<1>();");
        line("return std::vector<int>(buf.data(0), buf.data(0) + buf.size());");
        dedent();
        line("}");

        dedent();
        line();
        line("} // anonymous namespace");
        line();
    }

    // Helper to convert type_index to string
    std::string type_to_string(const std::type_index &ti) const {
        return rosetta::get_readable_type_name(ti);
    }

    void write_module() {
        line("// "
             "================================================================="
             "===========");
        line("// Pybind11 Module Definition");
        line("// "
             "================================================================="
             "===========");
        line();
        line("PYBIND11_MODULE(" + config_.module_name + ", m) {");
        indent();
        line("m.doc() = \"" + config_.description + "\";");
        line();
        line("// Register Rosetta classes");
        line(config_.get_registration_call() + ";");
        line();

        auto &registry = rosetta::Registry::instance();
        // Note: Registration must be called before generation
        // The actual call happens at runtime when the generated code is compiled

        auto class_names = registry.list_classes();
        auto sorted = topological_sort(class_names, registry);

        for (const auto &name : sorted) {
            auto *holder = registry.get_by_name(name);
            if (holder)
                write_class_binding(name, holder);
        }

        write_utility_functions();

        dedent();
        line("}");
    }

    std::vector<std::string>
    topological_sort(const std::vector<std::string> &names,
                     rosetta::Registry &registry) {
        std::vector<std::string> sorted;
        std::set<std::string> visited;
        std::set<std::string> name_set(names.begin(), names.end());

        std::function<void(const std::string &)> visit =
            [&](const std::string &n) {
                if (visited.count(n))
                    return;
                visited.insert(n);
                auto *h = registry.get_by_name(n);
                if (h) {
                    auto base = h->get_base_class();
                    if (!base.empty()) {
                        size_t pos = base.rfind("::");
                        std::string base_name = (pos != std::string::npos)
                                                    ? base.substr(pos + 2)
                                                    : base;
                        if (name_set.count(base_name))
                            visit(base_name);
                    }
                }
                sorted.push_back(n);
            };

        for (const auto &n : names)
            visit(n);
        return sorted;
    }

    void write_class_binding(const std::string &name,
                             const rosetta::core::Registry::MetadataHolder *holder) {
        line("// --- " + name + " ---");
        std::string cpp_type = holder->get_cpp_type_name();
        auto base = holder->get_base_class();

        std::string base_spec;
        if (!base.empty())
            base_spec = ", " + base;

        line("py::class_<" + cpp_type + base_spec + ", std::shared_ptr<" +
             cpp_type + ">>(m, \"" + name + "\")");
        indent();

        for (const auto &ctor : holder->get_constructors()) {
            write_constructor(cpp_type, ctor);
        }

        for (const auto &method : holder->get_methods()) {
            write_method(cpp_type, method, holder);
        }

        line(".def(\"__repr__\", [](const " + cpp_type + "&) { return \"<" +
             name + ">\"; })");
        line(";");
        dedent();
        line();
    }

    void write_constructor(const std::string &cpp_type,
                           const rosetta::ConstructorMeta &ctor) {
        auto params = ctor.get_param_types();
        if (params.empty()) {
            line(".def(py::init<>())");
        } else {
            bool needs_wrapper = std::any_of(
                params.begin(), params.end(), [this](const std::string &p) {
                    return needs_numpy_conversion(p);
                });

            if (needs_wrapper) {
                write_constructor_wrapper(cpp_type, params);
            } else {
                std::string p;
                for (size_t i = 0; i < params.size(); ++i) {
                    if (i > 0)
                        p += ", ";
                    p += normalize_type(params[i]);
                }
                line(".def(py::init<" + p + ">())");
            }
        }
    }

    void write_constructor_wrapper(const std::string &cpp_type,
                                   const std::vector<std::string> &params) {
        std::ostringstream w;
        w << ".def(py::init([](";
        std::vector<std::string> fwd;
        for (size_t i = 0; i < params.size(); ++i) {
            if (i > 0)
                w << ", ";
            w << get_python_param_type(params[i]) << " arg" << i;
            fwd.push_back(generate_input_conversion(params[i],
                                                    "arg" + std::to_string(i)));
        }
        w << ") { return std::make_shared<" << cpp_type << ">(";
        for (size_t i = 0; i < fwd.size(); ++i) {
            if (i > 0)
                w << ", ";
            w << fwd[i];
        }
        w << "); }))";
        line(w.str());
    }

    void write_method(const std::string &cpp_type, const std::string &name,
                      const rosetta::core::Registry::MetadataHolder *holder) {
        auto info = holder->get_method_info(name);
        bool needs = needs_numpy_wrapper(info.return_type, info.param_types);

        if (needs) {
            write_wrapped_method(cpp_type, name, info);
        } else {
            std::string policy = get_return_policy(info.return_type);
            if (!policy.empty()) {
                line(".def(\"" + name + "\", &" + cpp_type + "::" + name +
                     ", " + policy + ")");
            } else {
                line(".def(\"" + name + "\", &" + cpp_type + "::" + name + ")");
            }
        }
    }

    void write_wrapped_method(const std::string &cpp_type,
                              const std::string &name,
                              const rosetta::MethodInfo &info) {
        std::ostringstream w;
        std::string self =
            info.is_const ? "const " + cpp_type + "&" : cpp_type + "&";

        w << ".def(\"" << name << "\", [](" << self << " self";
        for (size_t i = 0; i < info.param_types.size(); ++i) {
            w << ", " << get_python_param_type(info.param_types[i]) << " arg"
              << i;
        }
        w << ") {\n";

        if (info.return_type == std::type_index(typeid(void))) {
            w << "            self." << name << "(";
            for (size_t i = 0; i < info.param_types.size(); ++i) {
                if (i > 0)
                    w << ", ";
                w << generate_input_conversion(info.param_types[i],
                                               "arg" + std::to_string(i));
            }
            w << ");\n";
        } else {
            w << "            auto result = self." << name << "(";
            for (size_t i = 0; i < info.param_types.size(); ++i) {
                if (i > 0)
                    w << ", ";
                w << generate_input_conversion(info.param_types[i],
                                               "arg" + std::to_string(i));
            }
            w << ");\n";
            w << "            return "
              << generate_output_conversion(info.return_type, "result")
              << ";\n";
        }
        w << "        })";
        line(w.str());
    }

    void write_utility_functions() {
        line("// Utilities");
        line("m.def(\"list_classes\", []() { return "
             "rosetta::Registry::instance().list_classes(); });");
        line("m.def(\"get_class_methods\", [](const std::string& n) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(n);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + n);");
        line("return h->get_methods();");
        dedent();
        line("});");
        line("m.def(\"version\", []() { return rosetta::version(); });");
    }

    // String-based helpers (used by constructor generation)
    bool needs_numpy_conversion(const std::string &t) {
        return t.find("Vector3") != std::string::npos ||
               t.find("Matrix33") != std::string::npos ||
               t.find("vector<") != std::string::npos;
    }

    // type_index overloads
    bool needs_numpy_conversion(const std::type_index &ti) {
        return needs_numpy_conversion(type_to_string(ti));
    }

    bool needs_numpy_wrapper(const std::string &ret,
                             const std::vector<std::string> &params) {
        if (needs_numpy_conversion(ret))
            return true;
        for (const auto &p : params)
            if (needs_numpy_conversion(p))
                return true;
        return false;
    }

    // type_index overload
    bool needs_numpy_wrapper(const std::type_index &ret,
                             const std::vector<std::type_index> &params) {
        if (needs_numpy_conversion(ret))
            return true;
        for (const auto &p : params)
            if (needs_numpy_conversion(p))
                return true;
        return false;
    }

    std::string normalize_type(const std::string &t) {
        std::string r = t;
        for (const auto &s : {"const ", "&"}) {
            size_t p;
            while ((p = r.find(s)) != std::string::npos)
                r.erase(p, strlen(s));
        }
        while (!r.empty() && r[0] == ' ')
            r.erase(0, 1);
        while (!r.empty() && r.back() == ' ')
            r.pop_back();
        return r;
    }

    std::string get_python_param_type(const std::string &t) {
        if (t.find("Vector3") != std::string::npos)
            return "py::array_t<double>";
        if (t.find("Matrix33") != std::string::npos)
            return "py::array_t<double>";
        if (t.find("vector<double>") != std::string::npos)
            return "py::array_t<double>";
        if (t.find("vector<int>") != std::string::npos)
            return "py::array_t<int>";
        return normalize_type(t);
    }

    // type_index overload
    std::string get_python_param_type(const std::type_index &ti) {
        return get_python_param_type(type_to_string(ti));
    }

    std::string generate_input_conversion(const std::string &t,
                                          const std::string &v) {
        if (t.find("Vector3") != std::string::npos)
            return "numpy_to_vector3(" + v + ")";
        if (t.find("vector<double>") != std::string::npos)
            return "numpy_to_vector_double(" + v + ")";
        if (t.find("vector<int>") != std::string::npos)
            return "numpy_to_vector_int(" + v + ")";
        return v;
    }

    // type_index overload
    std::string generate_input_conversion(const std::type_index &ti,
                                          const std::string &v) {
        return generate_input_conversion(type_to_string(ti), v);
    }

    std::string generate_output_conversion(const std::string &t,
                                           const std::string &v) {
        if (t.find("Vector3") != std::string::npos)
            return "vector3_to_numpy(" + v + ")";
        if (t.find("Matrix33") != std::string::npos)
            return "matrix33_to_numpy(" + v + ")";
        if (t.find("vector<double>") != std::string::npos)
            return "vector_double_to_numpy(" + v + ")";
        if (t.find("vector<int>") != std::string::npos)
            return "vector_int_to_numpy(" + v + ")";
        return v;
    }

    // type_index overload
    std::string generate_output_conversion(const std::type_index &ti,
                                           const std::string &v) {
        return generate_output_conversion(type_to_string(ti), v);
    }

    std::string get_return_policy(const std::string &t) {
        if (t.find("*") != std::string::npos)
            return "py::return_value_policy::reference_internal";
        if (t.find("&") != std::string::npos &&
            t.find("const") == std::string::npos)
            return "py::return_value_policy::reference_internal";
        return "";
    }

    // type_index overload
    std::string get_return_policy(const std::type_index &ti) {
        return get_return_policy(type_to_string(ti));
    }
};