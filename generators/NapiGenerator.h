#pragma once
#include "CodeWriter.h"
#include <rosetta/rosetta.h>

// ============================================================================
// N-API C++ Code Generator
// Generates Node.js native addon bindings from Rosetta metadata
// Uses node-addon-api (C++ wrapper for N-API)
// ============================================================================

class NapiGenerator : public CodeWriter {
public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_helpers();
        write_class_wrappers();
        write_init_function();
    }

private:
    void write_header() {
        line("// ============================================================================");
        line("// AUTO-GENERATED N-API BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// Module: " + config_.module_name);
        line("// ============================================================================");
        line();
    }

    void write_includes() {
        line("#include <napi.h>");
        line("#include <memory>");
        line("#include <vector>");
        line("#include <string>");
        line("#include <stdexcept>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();
        
        // Include source headers from config
        if (!config_.source_headers.empty()) {
            line("// Project headers");
            for (const auto& header : config_.source_headers) {
                line("#include <" + header + ">");
            }
            line();
        }
        
        // Include registration header
        if (!config_.registration_header.empty()) {
            line(config_.get_registration_include());
            line();
        }
    }

    void write_helpers() {
        // Get namespace prefix
        std::string ns = config_.types_namespace.empty() 
            ? "" 
            : config_.types_namespace + "::";

        line("// ============================================================================");
        line("// TypedArray <-> C++ conversion helpers");
        line("// ============================================================================");
        line("namespace {");
        line();
        indent();

        // Generic vector to TypedArray
        line("template<typename T>");
        line("Napi::Float64Array vectorToTypedArray(Napi::Env env, const std::vector<T>& vec) {");
        indent();
        line("auto arr = Napi::Float64Array::New(env, vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) {");
        indent();
        line("arr[i] = static_cast<double>(vec[i]);");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        // TypedArray to vector<double>
        line("std::vector<double> typedArrayToVectorDouble(const Napi::Float64Array& arr) {");
        indent();
        line("std::vector<double> vec(arr.ElementLength());");
        line("for (size_t i = 0; i < arr.ElementLength(); ++i) {");
        indent();
        line("vec[i] = arr[i];");
        dedent();
        line("}");
        line("return vec;");
        dedent();
        line("}");
        line();

        // TypedArray to vector<int>
        line("std::vector<int> typedArrayToVectorInt(const Napi::Int32Array& arr) {");
        indent();
        line("std::vector<int> vec(arr.ElementLength());");
        line("for (size_t i = 0; i < arr.ElementLength(); ++i) {");
        indent();
        line("vec[i] = arr[i];");
        dedent();
        line("}");
        line("return vec;");
        dedent();
        line("}");
        line();

        // Vector3 helpers
        line("Napi::Float64Array vector3ToTypedArray(Napi::Env env, const " + ns + "Vector3& v) {");
        indent();
        line("auto arr = Napi::Float64Array::New(env, 3);");
        line("arr[0] = v[0]; arr[1] = v[1]; arr[2] = v[2];");
        line("return arr;");
        dedent();
        line("}");
        line();

        line(ns + "Vector3 typedArrayToVector3(const Napi::Float64Array& arr) {");
        indent();
        line("if (arr.ElementLength() != 3) {");
        indent();
        line("throw std::runtime_error(\"Expected array of size 3 for Vector3\");");
        dedent();
        line("}");
        line("return " + ns + "Vector3(arr[0], arr[1], arr[2]);");
        dedent();
        line("}");
        line();

        // Matrix33 helpers
        line("Napi::Float64Array matrix33ToTypedArray(Napi::Env env, const " + ns + "Matrix33& m) {");
        indent();
        line("auto arr = Napi::Float64Array::New(env, 9);");
        line("for (int i = 0; i < 3; ++i) {");
        indent();
        line("for (int j = 0; j < 3; ++j) {");
        indent();
        line("arr[i * 3 + j] = m.get(i, j);");
        dedent();
        line("}");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        // Argument extraction helpers
        line("template<typename T>");
        line("T extractArg(const Napi::CallbackInfo& info, size_t index);");
        line();

        line("template<>");
        line("double extractArg<double>(const Napi::CallbackInfo& info, size_t index) {");
        indent();
        line("return info[index].As<Napi::Number>().DoubleValue();");
        dedent();
        line("}");
        line();

        line("template<>");
        line("int extractArg<int>(const Napi::CallbackInfo& info, size_t index) {");
        indent();
        line("return info[index].As<Napi::Number>().Int32Value();");
        dedent();
        line("}");
        line();

        line("template<>");
        line("std::string extractArg<std::string>(const Napi::CallbackInfo& info, size_t index) {");
        indent();
        line("return info[index].As<Napi::String>().Utf8Value();");
        dedent();
        line("}");
        line();

        line("template<>");
        line("bool extractArg<bool>(const Napi::CallbackInfo& info, size_t index) {");
        indent();
        line("return info[index].As<Napi::Boolean>().Value();");
        dedent();
        line("}");
        line();

        dedent();
        line("} // anonymous namespace");
        line();
    }

    void write_class_wrappers() {
        line("// ============================================================================");
        line("// Class Wrapper Definitions");
        line("// ============================================================================");
        line();

        auto& registry = rosetta::Registry::instance();
        auto class_names = registry.list_classes();

        for (const auto& name : class_names) {
            auto* holder = registry.get_by_name(name);
            if (holder && !config_.should_skip_class(name)) {
                write_class_wrapper(name, holder);
            }
        }
    }

    void write_class_wrapper(const std::string& name,
                             const rosetta::core::Registry::MetadataHolder* holder) {
        std::string cpp_type = holder->get_cpp_type_name();
        std::string wrapper_name = name + "Wrapper";

        line("// --- " + name + " ---");
        line("class " + wrapper_name + " : public Napi::ObjectWrap<" + wrapper_name + "> {");
        line("public:");
        indent();

        // Static Init method
        line("static Napi::Object Init(Napi::Env env, Napi::Object exports) {");
        indent();
        line("Napi::Function func = DefineClass(env, \"" + name + "\", {");
        indent();

        // Add method definitions
        auto methods = holder->get_methods();
        for (size_t i = 0; i < methods.size(); ++i) {
            const auto& m = methods[i];
            if (!config_.should_skip_method(name, m)) {
                std::string comma = (i < methods.size() - 1) ? "," : "";
                line("InstanceMethod<&" + wrapper_name + "::" + m + ">(\"" + m + "\")" + comma);
            }
        }

        dedent();
        line("});");
        line();
        line("Napi::FunctionReference* constructor = new Napi::FunctionReference();");
        line("*constructor = Napi::Persistent(func);");
        line("env.SetInstanceData(constructor);");
        line();
        line("exports.Set(\"" + name + "\", func);");
        line("return exports;");
        dedent();
        line("}");
        line();

        // Constructor
        line(wrapper_name + "(const Napi::CallbackInfo& info)");
        line("    : Napi::ObjectWrap<" + wrapper_name + ">(info) {");
        indent();
        line("Napi::Env env = info.Env();");
        
        auto ctors = holder->get_constructors();
        if (ctors.empty()) {
            line("instance_ = std::make_shared<" + cpp_type + ">();");
        } else {
            // Generate constructor overload handling
            line("size_t argc = info.Length();");
            line();
            
            bool first = true;
            for (const auto& ctor : ctors) {
                auto params = ctor.get_param_types();
                std::string condition = first ? "if" : "} else if";
                first = false;
                
                line(condition + " (argc == " + std::to_string(params.size()) + ") {");
                indent();
                
                if (params.empty()) {
                    line("instance_ = std::make_shared<" + cpp_type + ">();");
                } else {
                    // Extract arguments and construct
                    std::vector<std::string> args;
                    for (size_t i = 0; i < params.size(); ++i) {
                        std::string arg = generate_arg_extraction(params[i], i);
                        args.push_back(arg);
                    }
                    line("instance_ = std::make_shared<" + cpp_type + ">(" + join(args, ", ") + ");");
                }
                dedent();
            }
            line("} else {");
            indent();
            line("Napi::TypeError::New(env, \"Invalid number of arguments\").ThrowAsJavaScriptException();");
            dedent();
            line("}");
        }
        
        dedent();
        line("}");
        line();

        // Get underlying instance
        line("std::shared_ptr<" + cpp_type + "> GetInstance() { return instance_; }");
        line();

        // Generate method wrappers
        for (const auto& m : methods) {
            if (!config_.should_skip_method(name, m)) {
                write_method_wrapper(cpp_type, m, holder);
            }
        }

        dedent();
        line("private:");
        indent();
        line("std::shared_ptr<" + cpp_type + "> instance_;");
        dedent();
        line("};");
        line();
    }

    void write_method_wrapper(const std::string& cpp_type,
                              const std::string& method_name,
                              const rosetta::core::Registry::MetadataHolder* holder) {
        auto info = holder->get_method_info(method_name);
        auto param_types = info.get_param_types_str();
        auto return_type = info.get_return_type_str();

        line("Napi::Value " + method_name + "(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line();

        // Check argument count
        if (!param_types.empty()) {
            line("if (info.Length() < " + std::to_string(param_types.size()) + ") {");
            indent();
            line("Napi::TypeError::New(env, \"Wrong number of arguments\").ThrowAsJavaScriptException();");
            line("return env.Undefined();");
            dedent();
            line("}");
            line();
        }

        // Extract arguments
        std::vector<std::string> args;
        for (size_t i = 0; i < param_types.size(); ++i) {
            std::string arg = generate_arg_extraction(param_types[i], i);
            args.push_back(arg);
        }

        // Call method and return result
        if (return_type == "void") {
            line("instance_->" + method_name + "(" + join(args, ", ") + ");");
            line("return env.Undefined();");
        } else {
            line("auto result = instance_->" + method_name + "(" + join(args, ", ") + ");");
            line("return " + generate_return_conversion(return_type, "result") + ";");
        }

        dedent();
        line("}");
        line();
    }

    void write_init_function() {
        line("// ============================================================================");
        line("// Module Initialization");
        line("// ============================================================================");
        line();

        // Utility functions
        line("Napi::Value ListClasses(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("auto classes = rosetta::Registry::instance().list_classes();");
        line("auto arr = Napi::Array::New(env, classes.size());");
        line("for (size_t i = 0; i < classes.size(); ++i) {");
        indent();
        line("arr.Set(i, Napi::String::New(env, classes[i]));");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("Napi::Value GetClassMethods(const Napi::CallbackInfo& info) {");
        indent();
        line("Napi::Env env = info.Env();");
        line("if (info.Length() < 1 || !info[0].IsString()) {");
        indent();
        line("Napi::TypeError::New(env, \"String expected\").ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("std::string name = info[0].As<Napi::String>().Utf8Value();");
        line("auto* h = rosetta::Registry::instance().get_by_name(name);");
        line("if (!h) {");
        indent();
        line("Napi::Error::New(env, \"Class not found: \" + name).ThrowAsJavaScriptException();");
        line("return env.Undefined();");
        dedent();
        line("}");
        line("auto methods = h->get_methods();");
        line("auto arr = Napi::Array::New(env, methods.size());");
        line("for (size_t i = 0; i < methods.size(); ++i) {");
        indent();
        line("arr.Set(i, Napi::String::New(env, methods[i]));");
        dedent();
        line("}");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("Napi::Value Version(const Napi::CallbackInfo& info) {");
        indent();
        line("return Napi::String::New(info.Env(), rosetta::version());");
        dedent();
        line("}");
        line();

        // Main init function
        line("Napi::Object Init(Napi::Env env, Napi::Object exports) {");
        indent();
        
        // Call registration function
        if (!config_.registration_function.empty()) {
            line("// Register classes with Rosetta");
            line(config_.get_registration_call() + ";");
            line();
        }

        // Initialize all class wrappers
        auto& registry = rosetta::Registry::instance();
        for (const auto& name : registry.list_classes()) {
            if (!config_.should_skip_class(name)) {
                line(name + "Wrapper::Init(env, exports);");
            }
        }
        line();

        // Export utility functions
        line("exports.Set(\"listClasses\", Napi::Function::New(env, ListClasses));");
        line("exports.Set(\"getClassMethods\", Napi::Function::New(env, GetClassMethods));");
        line("exports.Set(\"version\", Napi::Function::New(env, Version));");
        line();
        line("return exports;");
        dedent();
        line("}");
        line();

        line("NODE_API_MODULE(" + config_.module_name + ", Init)");
    }

    // Helper methods for type conversion
    std::string generate_arg_extraction(const std::string& type, size_t index) {
        std::string idx = std::to_string(index);
        
        if (type.find("Vector3") != std::string::npos) {
            return "typedArrayToVector3(info[" + idx + "].As<Napi::Float64Array>())";
        }
        if (type.find("vector<double>") != std::string::npos) {
            return "typedArrayToVectorDouble(info[" + idx + "].As<Napi::Float64Array>())";
        }
        if (type.find("vector<int>") != std::string::npos) {
            return "typedArrayToVectorInt(info[" + idx + "].As<Napi::Int32Array>())";
        }
        if (type.find("string") != std::string::npos) {
            return "info[" + idx + "].As<Napi::String>().Utf8Value()";
        }
        if (type == "bool") {
            return "info[" + idx + "].As<Napi::Boolean>().Value()";
        }
        if (type == "int" || type == "long" || type == "size_t") {
            return "info[" + idx + "].As<Napi::Number>().Int32Value()";
        }
        if (type == "float" || type == "double") {
            return "info[" + idx + "].As<Napi::Number>().DoubleValue()";
        }
        
        // Default: assume it's a wrapped object type
        // TODO: Handle wrapped object types
        return "info[" + idx + "].As<Napi::Number>().DoubleValue()";
    }

    std::string generate_return_conversion(const std::string& type, const std::string& var) {
        if (type.find("Vector3") != std::string::npos) {
            return "vector3ToTypedArray(env, " + var + ")";
        }
        if (type.find("Matrix33") != std::string::npos) {
            return "matrix33ToTypedArray(env, " + var + ")";
        }
        if (type.find("vector<double>") != std::string::npos) {
            return "vectorToTypedArray(env, " + var + ")";
        }
        if (type.find("vector<int>") != std::string::npos) {
            return "vectorToTypedArray(env, " + var + ")";
        }
        if (type.find("string") != std::string::npos) {
            return "Napi::String::New(env, " + var + ")";
        }
        if (type == "bool") {
            return "Napi::Boolean::New(env, " + var + ")";
        }
        if (type == "int" || type == "long" || type == "size_t" ||
            type == "float" || type == "double") {
            return "Napi::Number::New(env, " + var + ")";
        }
        if (type == "void") {
            return "env.Undefined()";
        }
        
        // Default: convert to number (may need to handle object types)
        return "Napi::Number::New(env, " + var + ")";
    }
};
